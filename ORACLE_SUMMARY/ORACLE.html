<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ORACLE_SUMMARY</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <div class = "index">
      <a name = "인덱스"><h3>목차</h3></a>
      <ol>
        <a href="#구현기능"><li>구현기능</li></a><hr>
        <a href="#연결연산자 ||"><li>연결연산자 ||</li></a><hr>
        <a href="#DISTINCT"><li>DISTINCT</li></a><hr>
        <a href="#WHERE"><li>WHERE</li></a><hr>
        <a href="#집합연산자"><li>집합연산자</li></a><hr>
        <a href="#문자함수"><li>문자함수</li></a><hr>
        <a href="#숫자함수"><li>숫자함수</li></a><hr>
        <a href="#날짜함수"><li>날짜함수</li></a><hr>
        <a href="#형변환함수"><li>형변환함수</li></a><hr>
        <a href="#일반함수"><li>일반함수</li></a><hr>
        <a href="#정규식"><li>정규식</li></a><hr>
        <a href="#그룹함수"><li>그룹함수</li></a><hr>
        <a href="#PIVOT"><li>PIVOT</li></a><hr>
        <a href="#JOIN"><li>JOIN</li></a><hr>
        <a href="#DDL"><li>DDL</li></a><hr>
      </ol>
      <a href="#인덱스" name="구현기능"><h3>구현기능</h3></a><hr>
      <ul>
        <a href="#페이징"><h4>페이징</h4></a>
        <a href="#DECODE_연결연산자"><h4>DECODE_연결연산자</h4></a>
        <a href="#SUM_CASE"><h4>SUM_CASE</h4></a>
      </ul>
      <a href="#인덱스" name="연결연산자 ||"><h3>연결연산자 ||</h3></a><hr>
      <ul>
        <a href="#연결연산자"><h4>연결연산자</h4></a>
      </ul>
      <a href="#인덱스" name="DISTINCT"><h3>DISTINCT</h3></a><hr>
      <ul>
        <a href="#칼럼하나 중복제거"><h4>칼럼하나 중복제거</h4></a>
        <a href="#칼럼다중 중복제거"><h4>칼럼다중 중복제거</h4></a>
      </ul>
      <a href="#인덱스" name="WHERE"><h3>WHERE</h3></a><hr>
      <ul>
        <a href="#날짜 <,<=,>,>="><h4>날짜 <,<=,>,>=</h4></a>
        <a href="#BETWEEN"><h4>BETWEEN</h4></a>
        <a href="#IN"><h4>IN</h4></a>
        <a href="#LIKE"><h4>LIKE</h4></a>
        <a href="#AND"><h4>AND</h4></a>
        <a href="#OR"><h4>OR</h4></a>
        <a href="#AND&OR"><h4>AND&OR</h4></a>
        <a href="#PARAM"><h4>PARAM</h4></a>
        <a href="#ORDER BY"><h4>ORDER BY</h4></a>
      </ul>
      <a href="#인덱스" name="집합연산자"><h3>집합연산자</h3></a><hr>
      <ul>
        <a href="#UNION"><h4>UNION</h4></a>
        <a href="#UNION ALL"><h4>UNION ALL</h4></a>
        <a href="#INTERSECT"><h4>INTERSECT</h4></a>
        <a href="#MINUS"><h4>MINUS</h4></a>
      </ul>
      <a href="#인덱스" name="문자함수"><h3>문자함수</h3></a><hr>
      <ul>
        <a href="#INITCAP"><h4>INITCAP</h4></a>
        <a href="#LOWER | UPPER"><h4>LOWER | UPPER</h4></a>
        <a href="#LENGTH | LENGTHB"><h4>LENGTH | LENGTHB</h4></a>
        <a href="#CONCAT"><h4>CONCAT</h4></a>
        <a href="#SUBSTR"><h4>SUBSTR</h4></a>
        <a href="#INSTR"><h4>INSTR</h4></a>
        <a href="#LPAD"><h4>LPAD</h4></a>
        <a href="#RPAD"><h4>RPAD</h4></a>
        <a href="#LTRIM | RTRIM"><h4>LTRIM | RTRIM</h4></a>
        <a href="#REPLACE"><h4>REPLACE</h4></a>
      </ul>
      <a href="#인덱스" name="숫자함수"><h3>숫자함수</h3></a><hr>
      <ul>
        <a href="#ROUND"><h4>ROUND</h4></a>
        <a href="#TRUNC"><h4>TRUNC</h4></a>
        <a href="#MOD"><h4>MOD</h4></a>
        <a href="#CEIL"><h4>CEIL</h4></a>
        <a href="#FLOOR"><h4>FLOOR</h4></a>
        <a href="#POWER"><h4>POWER</h4></a>
        <a href="#ABS"><h4>ABS</h4></a>
        <a href="#SIGN"><h4>SIGN</h4></a>
      </ul>
      <a href="#인덱스" name="날짜함수"><h3>날짜함수</h3></a><hr>
      <ul>
        <a href="#SYSDATE"><h4>SYSDATE</h4></a>
        <a href="#MONTHS_BETWEEN"><h4>MONTHS_BETWEEN</h4></a>
        <a href="#ADD_MONTHS"><h4>ADD_MONTHS</h4></a>
        <a href="#NEXT_DAY"><h4>NEXT_DAY</h4></a>
        <a href="#LAST_DAY"><h4>LAST_DAY</h4></a>
        <a href="#ROUND/TRUNC"><h4>ROUND/TRUNC</h4></a>
        <a href="#EXTRACT"><h4>EXTRACT</h4></a>
        <a href="#TO_DATE"><h4>TO_DATE</h4></a>
      </ul>
      <a href="#인덱스" name="형변환함수"><h3>형변환함수</h3></a><hr>
      <ul>
        <a href="#DATA_TYPE"><h4>DATA_TYPE</h4></a>
        <a href="#TO_CHAR(DATE_TO_CHAR)"><h4>TO_CHAR(DATE_TO_CHAR)</h4></a>
        <a href="#TO_CHAR(NUMBER_TO_CHAR)"><h4>TO_CHAR(NUMBER_TO_CHAR)</h4></a>
        <a href="#TO_NUMBER"><h4>TO_NUMBER</h4></a>
        <a href="#TO_DATE"><h4>TO_DATE</h4></a>
      </ul>
      <a href="#인덱스" name="일반함수"><h3>일반함수</h3></a><hr>
      <ul>
        <a href="#NVL"><h4>NVL</h4></a>
        <a href="#NVL2"><h4>NVL2</h4></a>
        <a href="#DECODE"><h4>DECODE</h4></a>
        <a href="#CASE"><h4>CASE</h4></a>
      </ul>
      <a href="#인덱스" name="정규식"><h3>정규식</h3></a><hr>
      <ul>
        <a href="#META_CHARACTER"><h4>META_CHARACTER</h4></a>
        <a href="#REGEXP_LIKE"><h4>REGEXP_LIKE</h4></a>
        <a href="#REGEXP_REPLACE"><h4>REGEXP_REPLACE</h4></a>
        <a href="#REGEXP_SUBSTR"><h4>REGEXP_SUBSTR</h4></a>
        <a href="#REGEXP_COUNT"><h4>REGEXP_COUNT</h4></a>
      </ul>
      <a href="#인덱스" name="그룹함수"><h3>그룹함수</h3></a><hr>
      <ul>
        <a href="#그룹함수의_종류"><h4>그룹함수의_종류</h4></a>
        <a href="#COUNT"><h4>COUNT</h4></a>
        <a href="#SUM"><h4>SUM</h4></a>
        <a href="#AVG"><h4>AVG</h4></a>
        <a href="#MAX | MIN"><h4>MAX | MIN</h4></a>
        <a href="#VARIANCE | STDDEV"><h4>VARIANCE|STDDEV</h4></a>
        <a href="#GROUP_BY"><h4>GROUP_BY</h4></a>
        <a href="#HAVING"><h4>HAVING</h4></a>
        <a href="#ROLLUP"><h4>ROLLUP</h4></a>
        <a href="#CUBE"><h4>CUBE</h4></a>
        <a href="#GROUPING_SETS"><h4>GROUPING_SETS</h4></a>
        <a href="#PLAN"><h4>PLAN</h4></a>
        <a href="#LISTAGG"><h4>LISTAGG</h4></a>
        <a href="#XMLAGG"><h4>XMLAGG</h4></a>
        <a href="#PIVOT"><h4>PIVOT</h4></a>
        <a href="#UNPIVOT"><h4>UNPIVOT</h4></a>
        <a href="#LAG"><h4>LAG</h4></a>
        <a href="#LEAD"><h4>LEAD</h4></a>
        <a href="#RANK"><h4>RANK</h4></a>
        <a href="#RANK_OVER/DENSE_RANK/ROW_NUMBER"><h4>RANK_OVER/DENSE_RANK/ROW_NUMBER</h4></a>
        <a href="#SUM() OVER"><h4>SUM() OVER</h4></a>
        <a href="#RATIO_TO_REPORT"><h4>RATIO_TO_REPORT</h4></a>
      </ul>
      <a href="#인덱스" name="PIVOT"><h3>PIVOT</h3></a><hr>
      <ul>
        <a href="#DECODE구현"><h4>DECODE구현</h4></a>
        <a href="#달력구현"><h4>달력구현</h4></a>
        <a href="#다중조건"><h4>다중조건</h4></a>
        <a href="#가로세로컬럼"><h4>가로세로컬럼</h4></a>
        <a href="#PIVOT_CUBE"><h4>PIVOT_CUBE</h4></a>
      </ul>
      <a href="#인덱스" name="JOIN"><h3>JOIN</h3></a><hr>
      <ul>
        <a href="#JOIN_기본설명"><h4>JOIN_기본설명</h4></a>
        <a href="#CARTESIAN_PRODUCT"><h4>CARTESIAN_PRODUCT</h4></a>
        <a href="#EQUI_JOIN"><h4>EQUI_JOIN</h4></a>
        <a href="#NON_EQUI_JOIN"><h4>NON_EQUI_JOIN</h4></a>
        <a href="#OUTER_JOIN"><h4>OUTER_JOIN</h4></a>
        <a href="#SELF_JOIN"><h4>SELF_JOIN</h4></a>
      </ul>
      <a href="#인덱스" name="DDL"><h3>DDL</h3></a><hr>
      <ul>
        <a href="#명령어_구분"><h4>명령어_구분</h4></a>
        <a href="#CREATE"><h4>CREATE</h4></a>
        <a href="#CTAS"><h4>CTAS</h4></a>
        <a href="#ALTER"><h4>ALTER</h4></a>
      </ul>
    </div>
  </header>
  <pre>
<a href="#구현기능" name="페이징"><h4>페이징</h4></a><hr>
--PHASING
--OLTP (Online Transaction Processing) - 온라인 트랜잭션 처리
--OLAP (OnLine Analytical Processing) - 온라인 분석 처리

--기본 문법

<div class = "code">
--SELECT  TT1.*
--FROM(
--    SELECT rownum rnum,T1.*
--    FROM (
--        SELECT *
--        FROM member
--        --검색조건
--        ORDER BY mod_dt DESC
--    ) T1
--    WHERE rownum <= 10
--) TT1
WHERE rnum >=  1;
----WHERE rnum BETWEEN  1  AND 10;
</div>

--실제 사용 예
--가장 안쪽의 select절부터 읽어나감면 됨
--가장 안쪽의 select절을 T1이라 지정
--T1은 모든 데이터를 불러오는 select절
--중간의 select절을 TT1이라 지정
--TT1는 row 수를 출력하는 함수 rownum을 칼럼 rnum으로 출력, 그리고 T1의 모든 데이터 중 무엇을
--출력할 지 지정할 수 있음. T1.*은 모두 출력, T1.name은 이름만 출력하겠다는 것
--가장 바깥의 select절은 따로 이름을 줄 필요없음
--여기서 TT1의 모든 데이터 중 무엇을 출력할 지 정할 수 있음
--where 조건을 통해 row수를 조작 가능

<div class = "code">
SELECT TT1.*
FROM(
	SELECT rownum rnum,T1.*
	FROM(
		SELECT *
		FROM emp2
		ORDER BY birthday
	)T1
)TT1
WHERE rnum BETWEEN 1 AND 10
;
--   RNUM NAME                 POSITION                  DEPTNO
--------- -------------------- ------------------------- ------------
--      1 Kurt Russell         Boss                      0001
--      2 Keanu Reeves         Deputy Section chief      1005
--      3 Kevin Bacon          Department head           1003
--      4 Hugh Grant           Section head              1004
--      5 Chris O'Donnell      Section head              1007
--      6 AL Pacino            Department head           1000
--      7 Gene Hackman         Section head              1002
--      8 Woody Harrelson      Section head              1000
--      9 Tommy Lee Jones      Deputy department head    1001
--     10 Val Kilmer           Department head           1006
</div>
<a href="#구현기능" name="DECODE_연결연산자"><h4>DECODE_연결연산자</h4></a><hr>
--DECODE와 연결연산자를 이용하여 피벗테이블을 생성
--카운트 데이터 옆에 해당 데이터가 차지하는 비율을 출력
--기존 PIVOT 함수로는 구현이 불가능하므로 DECODE를 사용
--가장 안쪽의 SELECT문부터 읽어 나가면 쉽게 이해가능

<div class = "code">
COL "TOTAL"     FOR A15
COL "SEOUL"     FOR A15
COL "GYEONGGI"  FOR A15
COL "BUSAN"     FOR A15
COL "ULSAN"     FOR A15
COL "DAEGU"     FOR A15
COL "GYEONGNAM" FOR A22
SELECT TOTAL     ||'EA ('|| (TOTAL/TOTAL)*100     ||'%)'  "TOTAL"
      ,SEOUL     ||'EA ('|| (SEOUL/TOTAL)*100     ||'%)'  "SEOUL"
	  ,GYEONGGI  ||'EA ('|| (GYEONGGI/TOTAL)*100  ||'%)'  "GYEONGGI"
	  ,BUSAN     ||'EA ('|| (BUSAN/TOTAL)*100     ||'%)'  "BUSAN"
	  ,ULSAN     ||'EA ('|| (ULSAN/TOTAL)*100     ||'%)'  "ULSAN"
	  ,DAEGU     ||'EA ('|| (DAEGU/TOTAL)*100     ||'%)'  "DAEGU"
	  ,GYEONGNAM ||'EA ('|| (GYEONGNAM/TOTAL)*100 ||'%)'  "GYEONGNAM"
FROM (
	SELECT MAX(TOTAL) "TOTAL"
		  ,COUNT(DECODE(AREA_CD,'02' ,'1'))     "SEOUL"
		  ,COUNT(DECODE(AREA_CD,'031','1'))     "GYEONGGI"
		  ,COUNT(DECODE(AREA_CD,'051','1'))     "BUSAN"
		  ,COUNT(DECODE(AREA_CD,'052','1'))     "ULSAN"
		  ,COUNT(DECODE(AREA_CD,'053','1'))     "DAEGU"
		  ,COUNT(DECODE(AREA_CD,'055','1'))     "GYEONGNAM"
	FROM(
			SELECT COUNT(*) OVER() "TOTAL"
				  ,SUBSTR(tel,1,INSTR(tel,')')-1) "AREA_CD"
			FROM student
	)
);
--TOTAL       SEOUL       GYEONGGI   BUSAN      ULSAN    DAEGU       GYEONGNAM
------------- ----------- ---------- ---------- -------- ----------- -----------
--20EA (100%) 6EA (30%)   2EA (10%)  4EA (20%)  0EA (0%) 2EA (10%)   6EA (30%)
</div>
<a href="#구현기능" name="SUM_CASE"><h4>SUM_CASE</h4></a><hr>
--SUM/COUNT하는 조건을 줄 수 있다.
--해당하는 조건의 데이터를 카운트 하는 경우 아래와 같이 사용하면 된다.

<div class = "code">
SELECT SUM(CASE WHEN YEAR BETWEEN 0 AND 10 THEN 1 END) "10년",
	SUM(CASE WHEN YEAR BETWEEN 11 AND 15 THEN 1 END) "15년",
	SUM(CASE WHEN YEAR BETWEEN 16 AND 20 THEN 1 END) "20년"
FROM(
	SELECT TRUNC((SYSDATE-hire_date)/365)YEAR
	FROM employees
);
--      10년       15년       20년
------------ ---------- ----------
--                   80         27
</div>
<a href="#연결연산자 ||" name="연결연산자"><h4>연결연산자</h4></a><hr>
--연결연산자: ||
--컬럼을 붙여서 출력
--작은 따옴표를 쓰기 위해서는 ' '(') ' ()안의 작은따옴표만 출력

--example01

<div class = "code">
SELECT ename || ' ''s job is ' || job AS "NAME AND JOB"
FROM emp;
--NAME AND JOB
--------------------------------------------------------------
--SMITH 's job is CLERK
--ALLEN 's job is SALESMAN
--WARD 's job is SALESMAN
--JONES 's job is MANAGER
--MARTIN 's job is SALESMAN
--BLAKE 's job is MANAGER
--CLARK 's job is MANAGER
--KING 's job is PRESIDENT
--TURNER 's job is SALESMAN
--JAMES 's job is CLERK
--FORD 's job is ANALYST
--MILLER 's job is CLERK
</div>
--example02

<div class = "code">
SELECT name ||' ''s ID : ' || id ||', WEIGHT is ' || weight ||'Kg' AS "ID AND WEIGHT"
FROM student;
--
--ID AND WEIGHT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--James Seo 's ID : 75true, WEIGHT is 72Kg
--Rene Russo 's ID : Russo, WEIGHT is 64Kg
--Sandra Bullock 's ID : Bullock, WEIGHT is 52Kg
--Demi Moore 's ID : Moore, WEIGHT is 83Kg
--Danny Glover 's ID : Glover, WEIGHT is 70Kg
--Billy Crystal 's ID : Crystal, WEIGHT is 48Kg
--Nicholas Cage 's ID : Cage, WEIGHT is 42Kg
--Micheal Keaton 's ID : Keaton, WEIGHT is 55Kg
--Bill Murray 's ID : Murray, WEIGHT is 58Kg
--Macaulay Culkin 's ID : Culkin, WEIGHT is 54Kg
--Richard Dreyfus 's ID : Dreyfus, WEIGHT is 72Kg
--Tim Robbins 's ID : Robbins, WEIGHT is 70Kg
--Wesley Snipes 's ID : Snipes, WEIGHT is 82Kg
--Steve Martin 's ID : Martin, WEIGHT is 51Kg
--Daniel Day-Lewis 's ID : Day-Lewis, WEIGHT is 62Kg
--Danny Devito 's ID : Devito, WEIGHT is 48Kg
--Sean Connery 's ID : Connery, WEIGHT is 63Kg
--Christian Slater 's ID : Slater, WEIGHT is 69Kg
--Charlie Sheen 's ID : Sheen, WEIGHT is 81Kg
--Anthony Hopkins 's ID : Hopkins, WEIGHT is 51Kg
</div>
<a href="#DISTINCT" name="칼럼하나 중복제거"><h4>칼럼하나 중복제거</h4></a><hr>
--칼럼하나 중복제거

<div class = "code">
SELECT DISTINCT job
FROM emp
ORDER BY job;
--JOB
--------------------
--ANALYST
--CLERK
--MANAGER
--PRESIDENT
--SALESMAN
</div>
<a href="#DISTINCT" name="칼럼다중 중복제거"><h4>칼럼다중 중복제거</h4></a><hr>
--칼럼다중 중복제거

<div class = "code">
SELECT DISTINCT ename, job
FROM emp
ORDER BY 1,2;
--ENAME                JOB
---------------------- ------------------
--ALLEN                SALESMAN
--BLAKE                MANAGER
--CLARK                MANAGER
--FORD                 ANALYST
--JAMES                CLERK
--JONES                MANAGER
--KING                 PRESIDENT
--MARTIN               SALESMAN
--MILLER               CLERK
--SMITH                CLERK
--TURNER               SALESMAN
--WARD                 SALESMAN
</div>
<a href="#WHERE" name="날짜 <,<=,>,>="><h4>날짜 <,<=,>,>=</h4></a><hr>
--날짜 <,<=,>,>=

<div class = "code">
SELECT ename, hiredate
FROM emp
WHERE hiredate > '81/05/01';
--ENAME                HIREDATE
---------------------- --------
--MARTIN               81/09/28
--CLARK                81/06/09
--KING                 81/11/17
--TURNER               81/09/08
--JAMES                81/12/03
--FORD                 81/12/03
--MILLER               82/01/23
</div>
<a href="#WHERE" name="BETWEEN"><h4>BETWEEN</h4></a><hr>
--BETWEEN num AND num
--BETWEEN 보다 부등호가 연산이 빠르다

<div class = "code">
SELECT empno, ename, sal
FROM emp
WHERE sal BETWEEN 2000 AND 3000
ORDER BY sal;
--    EMPNO ENAME                       SAL
------------ -------------------- ----------
--      7782 CLARK                      2450
--      7698 BLAKE                      2850
--      7566 JONES                      2975
--      7902 FORD                       3000
</div>
<a href="#WHERE" name="IN"><h4>IN</h4></a><hr>
--IN(a,b,c): a이거나 b이거나 c이거나

<div class = "code">
SELECT empno, ename, deptno
FROM emp
WHERE deptno IN(10,20);
--     EMPNO ENAME                    DEPTNO
------------ -------------------- ----------
--      7369 SMITH                        20
--      7566 JONES                        20
--      7782 CLARK                        10
--      7839 KING                         10
--      7902 FORD                         20
--      7934 MILLER                       10
</div>
<a href="#WHERE" name="LIKE"><h4>LIKE</h4></a><hr>
--LIKE
--%는 *와 같다(모든것)
--_는 한 글자(어떤 글자가 와도 상관없다.)
--작은따옴표로 감싸줘야함

<div class = "code">
SELECT empno, ename, sal
FROM emp
WHERE sal LIKE '1%';
--     EMPNO ENAME                       SAL
------------ -------------------- ----------
--      7499 ALLEN                      1600
--      7521 WARD                       1250
--      7654 MARTIN                     1250
--      7844 TURNER                     1500
--      7934 MILLER                     1300
</div>
<a href="#WHERE" name="AND"><h4>AND</h4></a><hr>
--AND

<div class = "code">
SELECT ename,hiredate,sal
FROM emp
WHERE hiredate >= '82/01/23' AND sal >= 1300;
--ENAME                HIREDATE        SAL
---------------------- -------- ----------
--MILLER               82/01/23       1300
</div>
<a href="#WHERE" name="OR"><h4>OR</h4></a><hr>
--2.OR

<div class = "code">
SELECT ename,hiredate,sal
FROM emp
WHERE hiredate >= '82/01/23' OR sal >= 1300;
--ENAME                HIREDATE        SAL
---------------------- -------- ----------
--ALLEN                81/02/20       1600
--JONES                81/04/02       2975
--BLAKE                81/05/01       2850
--CLARK                81/06/09       2450
--KING                 81/11/17       5000
--TURNER               81/09/08       1500
--FORD                 81/12/03       3000
--MILLER               82/01/23       1300
</div>
<a href="#WHERE" name="AND&OR"><h4>AND&OR</h4></a><hr>
--AND와 OR함께 사용
--우선순위는 AND > OR
--괄호를 통해 우선순위 지정가능

<div class = "code">
SELECT ename,hiredate,sal,comm
FROM emp
WHERE (sal > 1000 OR comm > 1000) AND comm IS NULL;
ENAME                HIREDATE        SAL       COMM
---------------------- -------- ---------- ----------
--JONES                81/04/02       2975
--BLAKE                81/05/01       2850
--CLARK                81/06/09       2450
--KING                 81/11/17       5000
--FORD                 81/12/03       3000
--MILLER               82/01/23       1300
</div>
<a href="#WHERE" name="PARAM"><h4>PARAM</h4></a><hr>
--PARAM
--사용자에게 조건을 입력받아서 출력
--7369 찾기

--1.WHERE 칼럼 = &칼럼
--위와 같이 입력하면 칼럼값을 입력받아 찾아 출력한다.

<div class = "code">
SELECT ename,hiredate,sal,comm
FROM emp
WHERE empno = &empno;
--Enter value for empno: 7369
--ENAME                HIREDATE        SAL       COMM
---------------------- -------- ---------- ----------
--SMITH                80/12/17        800
</div>
--2.SELECT에서도 조건받아 출력

<div class = "code">
SELECT ename,hiredate, sal,&age AS age
FROM emp
WHERE empno = &empno;
--ENAME                HIREDATE        SAL        AGE
---------------------- -------- ---------- ----------
--SMITH                80/12/17        800         28
</div>
<a href="#WHERE" name="ORDER BY"><h4>ORDER BY</h4></a><hr>
--정렬하여 출력하기: ORDER BY 컬럼,컬럼
--정렬하여 출력하기: ORDER BY 1 ASC, 2 DESC
--DEFAULT는 ASC
--ORDER BY는 성능을 저하시키므로 사용하지 않는 것이 좋다.
--하지만 적은 수의 데이터의 경우에는 인덱스를 만드는 것보다 나음

--ASC
--한글: 가나다
--영문: ABC
--숫자: 1234
--날짜: 예전날짜부터

--1.sal값을 오름차순으로 정렬

<div class = "code">
SELECT ename,sal,hiredate
FROM emp
ORDER BY sal DESC;
--ENAME                       SAL HIREDATE
---------------------- ---------- --------
--KING                       5000 81/11/17
--FORD                       3000 81/12/03
--JONES                      2975 81/04/02
--BLAKE                      2850 81/05/01
--CLARK                      2450 81/06/09
--ALLEN                      1600 81/02/20
--TURNER                     1500 81/09/08
--MILLER                     1300 82/01/23
--MARTIN                     1250 81/09/28
--WARD                       1250 81/02/22
--JAMES                       950 81/12/03
--SMITH                       800 80/12/17
</div>
--2.칼럼순서로 정렬지정

<div class = "code">
SELECT deptno,ename,sal,hiredate
FROM emp
ORDER BY 1 DESC, 3ASC;
   -- DEPTNO ENAME                       SAL HIREDATE
------------ -------------------- ---------- --------
   --     30 JAMES                       950 81/12/03
   --     30 WARD                       1250 81/02/22
   --     30 MARTIN                     1250 81/09/28
   --     30 TURNER                     1500 81/09/08
   --     30 ALLEN                      1600 81/02/20
   --     30 BLAKE                      2850 81/05/01
   --     20 SMITH                       800 80/12/17
   --     20 JONES                      2975 81/04/02
   --     20 FORD                       3000 81/12/03
   --     10 MILLER                     1300 82/01/23
   --     10 CLARK                      2450 81/06/09
   --     10 KING                       5000 81/11/17
</div>
<a href="#집합연산자" name="UNION"><h4>UNION</h4></a><hr>
--1.UNION -> 중복값제거와 정렬
--ORDER BY가 들어가 있기때문에 성능 많이 먹음

<div class = "code">
SELECT studno,name
FROM student
WHERE deptno1 = 101
UNION
SELECT studno,name
FROM student
WHERE deptno2 = 201;
--    STUDNO NAME
------------ ------------------------------------------------------------
--      9411 James Seo
--      9511 Billy Crystal
--      9512 Nicholas Cage
--      9611 Richard Dreyfus
--      9711 Danny Devito
</div>
<a href="#집합연산자" name="UNION ALL"><h4>UNION ALL</h4></a><hr>
--2.UNION ALL -> 그냥합침

<div class = "code">
SELECT studno,name
FROM student
WHERE deptno1 = 101
UNION ALL
SELECT studno,name
FROM student
WHERE deptno2 = 201;
--    STUDNO NAME
------------ ------------------------------------------------------------
--      9411 James Seo
--      9511 Billy Crystal
--      9611 Richard Dreyfus
--      9711 Danny Devito
--      9411 James Seo
--      9512 Nicholas Cage
</div>
<a href="#집합연산자" name="INTERSECT"><h4>INTERSECT</h4></a><hr>

<div class = "code">
SELECT studno,name
FROM student
WHERE deptno1 = 101
INTERSECT
SELECT studno,name
FROM student
WHERE deptno2 = 201;
--    STUDNO NAME
------------ ------------------------------------------------------------
--      9411 James Seo
</div>
<a href="#집합연산자" name="MINUS"><h4>MINUS</h4></a><hr>
--4.MINUS -> 차집합

<div class = "code">
SELECT studno,name
FROM student
WHERE deptno1 = 101
MINUS
SELECT studno,name
FROM student
WHERE deptno2 = 201;
--    STUDNO NAME
------------ ------------------------------------------------------------
--      9511 Billy Crystal
--      9611 Richard Dreyfus
--      9711 Danny Devito
</div>
<a href="#문자함수" name="INITCAP"><h4>INITCAP</h4></a><hr>
--INITCAP(): 영어에서 첫 글자만 대문자로 출력
--INITCAP('ABCD') -> Abcd

<div class = "code">
SELECT ename , INITCAP(ename) "INITCAP"
FROM emp
WHERE deptno = 10;
--ENAME                INITCAP
---------------------- --------------------
--CLARK                Clark
--KING                 King
--MILLER               Miller
</div>
<a href="#문자함수" name="LOWER | UPPER"><h4>LOWER | UPPER</h4></a><hr>
--LOWER(), UPPER()

<div class = "code">
SELECT ename, LOWER(ename) "LOWER", UPPER(ename) "UPPER"
FROM emp
WHERE deptno = 10;
--ENAME                LOWER                UPPER
---------------------- -------------------- --------------------
--CLARK                clark                CLARK
--KING                 king                 KING
--MILLER               miller
</div>
<a href="#문자함수" name="LENGTH | LENGTHB"><h4>LENGTH | LENGTHB</h4></a><hr>
--LENGTH(), LENGTHB()
--LENGTH(문자열 또는 컬럼): 입력된 문자열의 길이를 RETURN
--LENGTHB(문자열 또는 컬럼): 입력된 문자열의 길이를 BYTE로 RETURN

<div class = "code">
SELECT ename, LENGTH(ename) "LENGTH", LENGTHB(ename) "LENGTHB"
FROM emp
WHERE deptno = 10;
--ENAME                    LENGTH    LENGTHB
---------------------- ---------- ----------
--CLARK                         5          5
--KING                          4          4
--MILLER                        6          6
</div>
<a href="#문자함수" name="CONCAT"><h4>CONCAT</h4></a><hr>
--CONCAT(): 두 문자열을 결합해서 출력. ||연산자와 동일
--CONCAT('A','B') -> AB

<div class = "code">
SELECT CONCAT(ename,job)
FROM emp
WHERE deptno = 10;
--CONCAT(ENAME,JOB)
----------------------------------------
--CLARKMANAGER
--KINGPRESIDENT
--MILLERCLERK
</div>
<a href="#문자함수" name="SUBSTR"><h4>SUBSTR</h4></a><hr>
--SUBSTR(): 주어진 문자열에서 특정 길이의 문자를 잘라 낼때 사용
--SUBSTR('문자열 또는 컬럼',num1,num2)
--num1부터 num2개만큼 출력
--num1이 양수이면 왼쪽에서 num1부터 num2개만큼 출력
--num1이 음수이면 오른쪽에서 num1부터 num2개만큼 출력

<div class = "code">
COL "3,2" FOR a6
COL "-3,2" FOR a6
COL "-3,4" FOR a6
SELECT SUBSTR('ABCDE',3,2) "3,2",SUBSTR('ABCDE',-3,2) "-3,2",SUBSTR('ABCDE',-3,4) "-3,4"
FROM dual;
--3,2    -3,2   -3,4
-------- ------ ------
--CD     CD     CDE
</div>
<div class = "code">
SELECT name, jumin , SUBSTR(jumin,3,4) "BIRTHDAY", SUBSTR(jumin,3,4)-1 "BIRTHDAY -1"
from student
WHERE deptno1 = 101;
--NAME            JUMIN               BIRTHDAY       BIRTHDAY -1
----------------- -------------       -------------- -----------
--James Seo       7510231901813       1023                  1022
--Billy Crystal   7601232186327       0123                   122
--Richard Dreyfus 7711291186223       1129                  1128
--Danny Devito    7808192157498       0819                   818
</div>
<a href="#문자함수" name="INSTR"><h4>INSTR</h4></a><hr>
--INSTR(): 주어진 문자열에서 특정 글자의 위치를 찾아주는 함수
--INSTR(문자열 또는 칼럼, char, num(DEFAULT 1))
--문자열 또는 칼럼에서 num번째 글자부터 char의 위치를 찾아 반환
--ex.INSTR('ABADA','A',2) -> 3 (B부터 탐색시작)
--num이 음수이면 오른쪽에서 부터

<div class = "code">
SELECT 'A-B-C-D', INSTR('A-B-C-D','-')"INSTR"
FROM dual;
--'A-B-C-D'      INSTR
---------------- -----
--A-B-C-D            2
</div>
<div class = "code">
SELECT 'A-B-C-D', INSTR('A-B-C-D','-',3)"INSTR"
FROM dual;
--'A-B-C-D'      INSTR
---------------- -----
--A-B-C-D            4
</div>
<div class = "code">
SELECT 'A-B-C-D', INSTR('A-B-C-D','-',-1)"INSTR"
FROM dual;
--'A-B-C-D'      INSTR
---------------- -----
--A-B-C-D            6
</div>
<div class = "code">
COL name FOR a16
COL tel FOR a14
COL "INSTR" FOR 9
COL "SUBSTR" FOR a4
SELECT name, tel, INSTR(tel,')') "INSTR", SUBSTR(tel,1,INSTR(tel,')')-1) "SUBSTR"
FROM student
WHERE deptno1 = 201;
--NAME             TEL            INSTR SUBS
------------------ -------------- ----- ----
--Demi Moore       02)6255-9875       3 02
--Macaulay Culkin  02)312-9838        3 02
--Wesley Snipes    053)736-4981       4 053
--Steve Martin     02)6175-3945       3 02
--Sean Connery     02)381-5440        3 02
--Christian Slater 031)345-5677       4 031
</div>
<a href="#문자함수" name="LPAD"><h4>LPAD</h4></a><hr>
--LPAD(): 주어진 문자열에서 왼쪽으로 특정문자를 채움
--LPAD('love',6,'*') -> **love

<div class = "code">
COL name FOR a16
COL ID FOR a10
COL "10LENGTH WITH *" FOR a20
SELECT name, ID, LPAD(ID,10,'*') "10LENGTH WITH *"
FROM student
WHERE deptno1 = 201;
--NAME             ID         10LENGTH WITH *
------------------ ---------- --------------------
--Demi Moore       Moore      *****Moore
--Macaulay Culkin  Culkin     ****Culkin
--Wesley Snipes    Snipes     ****Snipes
--Steve Martin     Martin     ****Martin
--Sean Connery     Connery    ***Connery
--Christian Slater Slater     ****Slater
</div>
--LPAD연습문제
--emp테이블, deptno가 10번인 사원들의 ename을 총 9바이트로 출력하되
--빈자리에는 해당 자리의 숫자로 채우시오
--ex.1234CLARK

<div class = "code">
SELECT LPAD(ename,9,'123456789') "LPAD"
FROM emp
WHERE deptno = 10;
--LPAD
---------------
--1234CLARK
--12345KING
--123MILLER
</div>
<a href="#문자함수" name="RPAD"><h4>RPAD</h4></a><hr>
--RPAD(): 주어진 문자열에서 오른쪽으로 특정문자를 채움
--RPAD('love',6,'*') -> love**

<div class = "code">
SELECT RPAD(ename,10,'*')
FROM emp
WHERE deptno = 10;
--RPAD(ENAME,10,'*')
------------------
--CLARK*****
--KING******
--MILLER****
</div>
--RPAD연습문제
--emp테이블, deptno가 10번인 사원들의 ename을 총 9자리로 출력하되
--오른쪽 빈자리에는 해당 자릿수에 해당되는 숫자를 출력되도록 하세요.

<div class = "code">
SELECT RPAD(ename,9,SUBSTR('123456789',LENGTH(ename)+1))"RPAD"
FROM emp
WHERE deptno = 10;
--RPAD
------------------
--CLARK6789
--KING56789
--MILLER789
</div>
<a href="#문자함수" name="LTRIM | RTRIM"><h4>LTRIM | RTRIM</h4></a><hr>
--LTRIM(): 주어진 문자열에서 왼쪽의 특정 문자를 삭제
--LTRIM('*love','*') -> love
--RTRIM(): 주어진 문자열에서 오른쪽의 특정 문자를 삭제
--RTRIM('love*','*') -> love

<div class = "code">
SELECT ename, LTRIM(ename,'C'), RTRIM(ename,'R')
FROM emp
WHERE deptno = 10;
--ENAME                LTRIM(ENAME,'C')     RTRIM(ENAME,'R')
---------------------- -------------------- --------------------
--CLARK                LARK                 CLARK
--KING                 KING                 KING
--MILLER               MILLER               MILLE
</div>
<a href="#문자함수" name="REPLACE"><h4>REPLACE</h4></a><hr>
--REPLACE(): 주어진 문자열에서 A를 B로 치환
--REPLACE('AB','A','E') -> EB

<div class = "code">
SELECT ename, REPLACE(ename,SUBSTR(ename,1,2),'**')"**name"
FROM emp
WHERE deptno = 10;
--ENAME                **name
---------------------- -----------
--CLARK                **ARK
--KING                 **NG
--MILLER               **LLER
</div>
--REPLACE연습문제1
--emp테이블, dept가 20, 소속된 직원들의 ename과 2~3번째 글자만 '-'으로 변경하여 출력

<div class = "code">
SELECT ename, REPLACE(ename,SUBSTR(ename,3,2),'--')"REPLACE"
FROM emp
WHERE deptno = 20;
--ENAME                REPLACE
---------------------- ----------------------------------------
--SMITH                SM--H
--JONES                JO--S
--FORD                 FO--
</div>
--REPLACE연습문제2
--student테이블, deptno1이 101, name, jumin과 뒤의 일곱자리가 -와 /로 교대로 출력되게 하시오

<div class = "code">
SELECT name, jumin, REPLACE(jumin,SUBSTR(jumin,7),'-/-/-/-')"REPLACE"
FROM student
WHERE deptno1 = 101;
--NAME             JUMIN         REPLACE
------------------ ------------- -----------------
--James Seo        7510231901813 751023-/-/-/-
--Billy Crystal    7601232186327 760123-/-/-/-
--Richard Dreyfus  7711291186223 771129-/-/-/-
--Danny Devito     7808192157498 780819-/-/-/-
</div>
--REPLACE연습문제3
--student테이블, deptno1이 102, name, tel, 국번을 '*'처리하여 출력

<div class = "code">
SELECT name, tel, REPLACE(tel,SUBSTR(tel,5,3),'***')"REPLACE"
FROM student
WHERE deptno1 = 102;
--NAME             TEL            REPLACE
------------------ -------------- -----------------
--Rene Russo       051)426-1700   051)***-1700
--Nicholas Cage    051)418-9627   051)***-9627
--Tim Robbins      055)488-2998   055)***-2998
--Charlie Sheen    055)423-9870   055)***-9870
</div>
--REPLACE연습문제4
--student테이블, deptno1이 101, name, tel, 지역번호와 국번외의 번호를 '*'처리 출력

<div class = "code">
SELECT name, tel
	, REPLACE
		(tel
		,SUBSTR(tel,INSTR(tel,'-',-1)+1,LENGTH(SUBSTR(tel,INSTR(tel,'-',-1)+1)))
		--전화번호에서 가장 오른쪽에 있는 '-'의 위치 = INSTR(tel,'-',-1)
		--가장 마지막 번호나열은 = INSTR(tel,'-',-1)+1 부터
		--그 번호나열의 길이는 = LENGTH(SUBSTR(tel,INSTR(tel,'-',-1)+1))
		,'****')
	"REPLACE"
FROM student
WHERE deptno1 = 101;
--NAME             TEL            REPLACE
------------------ -------------- ---------------
--James Seo        055)381-2158   055)381-****
--Billy Crystal    055)333-6328   055)333-****
--Richard Dreyfus  02)6788-4861   02)6788-****
--Danny Devito     055)278-3649   055)278-****
</div>
<a href="#숫자함수" name="ROUND"><h4>ROUND</h4></a><hr>
--ROUND(num1, num2): 주어진 숫자를 반올림한 후 출력함
--num1의 소숫점을 num2자리로 반올림. num2를 따로 지정안하면 소수 첫째자리에서 반올림
--ROUND(12.345,2) -> 12.35

<div class = "code">
SELECT ROUND(987.654), ROUND(987.654,1), ROUND(987.654,2), ROUND(987.654,-1)
FROM dual;
--ROUND(987.654) ROUND(987.654,1) ROUND(987.654,2) ROUND(987.654,-1)
---------------- ---------------- ---------------- -----------------
--           988            987.7           987.65               990
</div>
<a href="#숫자함수" name="TRUNC"><h4>TRUNC</h4></a><hr>
--TRUNC(num1, num2): 소숫값을 버림
--num1의 소수 자리를 num2자리로 맞추고 소숫값은 버림. num2를 따로 지정안하면 소수 첫째자리에서 올림
--TRUNC(12.345,2) -> 12.34

<div class = "code">
SELECT TRUNC(987.654), TRUNC(987.654,1), TRUNC(987.654,2), TRUNC(987.654,-1)
FROM dual;
--TRUNC(987.654) TRUNC(987.654,1) TRUNC(987.654,2) TRUNC(987.654,-1)
---------------- ---------------- ---------------- -----------------
--           987            987.6           987.65               980
</div>
<a href="#숫자함수" name="MOD"><h4>MOD</h4></a><hr>
--MOD(num1, num2): 주어진 숫자를 나눈 후 나머지 값을 출력함
--num1을 num2로 나눈 나머지
--MOD(12,2) -> 2

<div class = "code">
SELECT MOD(121,10)
FROM dual;
--MOD(121,10)
-------------
--          1
</div>
<a href="#숫자함수" name="CEIL"><h4>CEIL</h4></a><hr>
--CEIL(num1): 주어진 숫자와 가장 근접한 큰 정수를 출력함
--CELL(12.345) -> 13

<div class = "code">
SELECT CEIL(121.10)
FROM dual;
--CEIL(121.10)
--------------
--         122
</div>
--CEIL을 이용한 페이징

<div class = "code">
SELECT rownum, CEIL(rownum/3), ename
FROM emp;
--    ROWNUM CEIL(ROWNUM/3) ENAME
------------ -------------- --------------------
--         1              1 SMITH
--         2              1 ALLEN
--         3              1 WARD
--         4              2 JONES
--         5              2 MARTIN
--         6              2 BLAKE
--         7              3 CLARK
--         8              3 KING
--         9              3 TURNER
--        10              4 JAMES
--        11              4 FORD
--        12              4 MILLER
</div>
<a href="#숫자함수" name="FLOOR"><h4>FLOOR</h4></a><hr>
--FLOOR(num1): 주어진 숫자와 가장 근접한 작은 정수를 출력함
--FLOOR(12.345) -> 12

<div class = "code">
SELECT FLOOR(121.10)
FROM dual;
--FLOOR(121.10)
---------------
--          121
</div>
<a href="#숫자함수" name="POWER"><h4>POWER</h4></a><hr>
--POWER(num1, num2): 주어진 숫자 1의 숫자2제곱을 출력함.
--num1의 num2제곱
--POWER(3,2) -> 9

<div class = "code">
SELECT POWER(2,5)
FROM dual;
--POWER(2,5)
------------
--        32
</div>
<a href="#숫자함수" name="ABS"><h4>ABS</h4></a><hr>
--ABS(num): 주어진 숫자의 절대값을 출력

<div class = "code">
SELECT ABS(-33)
FROM dual;
--  ABS(-33)
------------
--        33
</div>
<a href="#숫자함수" name="SIGN"><h4>SIGN</h4></a><hr>
--SIGN(): 숫자가 양수인지 음수인지, 0인지 구분

<div class = "code">
SELECT SIGN(33),SIGN(-33),SIGN(0)
FROM dual;
--  SIGN(33)  SIGN(-33)    SIGN(0)
------------ ---------- ----------
--         1         -1          0
</div>
<a href="#날짜함수" name="SYSDATE"><h4>SYSDATE</h4></a><hr>
--SYSDATE: 시스템의 현재 날짜와 시간
--ALTER SESSION SET NLS_DATE_FORMAT = 'RRRR-MM-DD:HH24:MI:SS';
--데이트 포맷을 바꿔줌

<div class = "code">
SELECT SYSDATE
FROM dual;
--SYSDATE
---------------------
--2021-02-01:09:19:49
</div>
<a href="#날짜함수" name="MONTHS_BETWEEN"><h4>MONTHS_BETWEEN</h4></a><hr>
--MONTHS_BETWEEN: 두 날짜 사이의 개월 수

<div class = "code">
SELECT MONTHS_BETWEEN('2021/04/14','2021/02/01')"SUBTRACT"
	,MONTHS_BETWEEN('2021/02/01','2021/04/01')"SUBTRACT2"
	,MONTHS_BETWEEN('2021/02/01','2021/02/01')"SUBTRACT3"
FROM dual;
--  SUBTRACT  SUBTRACT2  SUBTRACT3
------------ ---------- ----------
--2.41935484         -2          0
</div>
<a href="#날짜함수" name="ADD_MONTHS"><h4>ADD_MONTHS</h4></a><hr>
--ADD_MONTHS: 주어진 날짜에 개월을 더함

<div class = "code">
COL "ADD_ONE_MONTH" FOR a15
COL "SUBTRACT_TWO_MONTH" FOR a20
SELECT SYSDATE
	,ADD_MONTHS(SYSDATE, 1)"ADD_ONE_MONTH"
	,ADD_MONTHS(SYSDATE, -2)"SUBTRACT_TWO_MONTH"
FROM dual;
--SYSDATE  ADD_ONE_MONTH   SUBTRACT_TWO_MONTH
---------- --------------- --------------------
--21/02/01 21/03/01        20/12/01
</div>
<a href="#날짜함수" name="NEXT_DAY"><h4>NEXT_DAY</h4></a><hr>
--NEXT_DAY: 주어진 날짜를 기준으로 돌아오는 날짜 출력
--WINDOWS: NEXT_DAY(SYSDATE,'수')
--UNIX: NEXT_DAY(SYSDATE,'WED')

<div class = "code">
SELECT SYSDATE
	,NEXT_DAY(SYSDATE,'수')
FROM dual;
--SYSDATE  NEXT_DAY
---------- --------
--21/02/01 21/02/03
</div>
<a href="#날짜함수" name="LAST_DAY"><h4>LAST_DAY</h4></a><hr>
--LAST_DAY: 주어진 날짜가 속한 달의 마지막 날짜출력

<div class = "code">
SELECT SYSDATE
	,LAST_DAY(SYSDATE)
FROM dual;
--SYSDATE  LAST_DAY
---------- --------
--21/02/01 21/02/28
</div>
<a href="#날짜함수" name="ROUND/TRUNC"><h4>ROUND/TRUNC</h4></a><hr>
--ROUND: 주어진 날짜를 반올림
--예)상품접수 및 배송(12:00 이후 그 다음날)
--TRUNC: 주어진 날짜를 버림
--예)원서접수(무조건 당일)

<div class = "code">
COL ROUND(SYSDATE) FOR A15
COL TRUNC(SYSDATE) FOR A15
SELECT SYSDATE
	,ROUND(SYSDATE)
	,TRUNC(SYSDATE)
FROM dual;
SYSDATE  ROUND(SYSDATE)  TRUNC(SYSDATE)
-------- --------------- ---------------
21/02/09 21/02/10        21/02/09
</div>
<a href="#날짜함수" name="EXTRACT"><h4>EXTRACT</h4></a><hr>
--EXTRACT: 날짜에서 년,월,일 추출

<div class = "code">
SELECT ename, hiredate
	,EXTRACT(YEAR FROM hiredate)"입사년도"
	,EXTRACT(MONTH FROM hiredate)"입사월"
	,EXTRACT(DAY FROM hiredate)"입사일"
FROM emp;
--ENAME                HIREDATE   입사년도     입사월     입사일
---------------------- -------- ---------- ---------- ----------
--SMITH                80/12/17       1980         12         17
--ALLEN                81/02/20       1981          2         20
--WARD                 81/02/22       1981          2         22
--JONES                81/04/02       1981          4          2
--MARTIN               81/09/28       1981          9         28
--BLAKE                81/05/01       1981          5          1
--CLARK                81/06/09       1981          6          9
--KING                 81/11/17       1981         11         17
--TURNER               81/09/08       1981          9          8
--JAMES                81/12/03       1981         12          3
--FORD                 81/12/03       1981         12          3
--MILLER               82/01/23       1982          1         23
</div>
<a href="#날짜함수" name="TO_DATE"><h4>TO_DATE</h4></a><hr>
--TO_DATE: 날짜가 아닌 날짜처럼 생긴 문자를 날짜로 바꿔주는 함수

<div class = "code">
SELECT TO_DATE('20210201')"date"
FROM dual;
--date
----------
--21/02/01
</div>

<a href="#형변환함수" name="DATA_TYPE"><h4>DATA_TYPE</h4></a><hr>
--CHAR(n): 고정길이의 문자를 저장, 최댓값은 2000바이트(꼭 고정된 길이의 데이터에만 쓸 것)
--VARCHAR2(n): 변하는 길이의 문자를 저장, 최댓값은 4000바이트
--NUMBER(p,s): 숫자 값을 저장, P는 전체 자릿수로 1~38자리까지 가능, s는 소술점 이하 자릿수로 -84~127자리까지 가능
--DATE: 총 7바이트로 BC4712년 1월 1일부터 AD9999년 12월 31일까지의 날짜를 저장가능
--LONG: 가변길이의 문자를 저장하며 최대 2GB까지 저장가능(앞으로 없어질 가능성이 있으므로 사용자제)
--CLOB: 가변길이의 문자를 저장하며 최대 4GB까지 저장가능
--BLOB: 가변길이의 바이너리 데이터를 최대 4GB까지 저장가능
--RAW(n): 원시이진 데이터로 최대 2000바이트까지 저장가능
--LONG RAW(n): 원시이진 데이터로 최대 2GB까지 저장가능
--BFILE: 외부파일에 저장된 데이터로 최대 4GB까지 저장가능

--묵시적(자동) 형변환
--해당컬럼에 인덱스가 생성되어 있을 경우 못쓰게 되어 속도가 느려짐

<div class = "code">
SELECT '11'+'13'
FROM dual;
-- '11'+'13'
------------
</div>
<a href="#형변환함수" name="TO_CHAR(DATE_TO_CHAR)"><h4>TO_CHAR(DATE_TO_CHAR)</h4></a><hr>
--TO_CHAR: 날짜 -> 문자
--TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')
<table>
  <tr>
    <th>종류</th>
    <th>의미</th>
    <th>사용예</th>
  </tr>
  <tr>
    <td>YYYY</td>
    <td>연도를 4자리로 표시</td>
    <td>2021</td>
  </tr>
  <tr>
    <td>RRRR</td>
    <td>위와 동일</td>
    <td>2021</td>
  </tr>
  <tr>
    <td>YY</td>
    <td>연도의 끝자리 2자리</td>
    <td>21</td>
  </tr>
  <tr>
    <td>RR</td>
    <td>위와 동일</td>
    <td>21</td>
  </tr>
  <tr>
    <td>YEAR</td>
    <td>연도의 영문명 전체</td>
    <td>TWENTY TWENTY ONE</td>
  </tr>
  <tr>
    <td>MM</td>
    <td>월을 숫자 2자리로</td>
    <td>02</td>
  </tr>
  <tr>
    <td>MON</td>
    <td>월(유닉스는 영3글자,윈도우는 MONTH와 동일)</td>
    <td>FEB</td>
  </tr>
  v
  <tr>
    <td>MONTH</td>
    <td>월의 영문명 전체</td>
    <td>FEBRUARY</td>
  </tr>
  <tr>
    <td>DD</td>
    <td>일을 숫자 2자리로</td>
    <td>26</td>
  </tr>
  <tr>
    <td>DAY</td>
    <td>요일(유닉스는 영문,윈도우는 한글)	</td>
    <td>월요일</td>
  </tr>
  <tr>
    <td>DDTH</td>
    <td>몇 번째 날인지를 표시</td>
    <td>22ND</td>
  </tr>
  <tr>
    <td>HH24</td>
    <td>하루를 24시간으로 표시</td>
    <td>23</td>
  </tr>
  <tr>
    <td>HH</td>
    <td>하루를 12시간으로 표시</td>
    <td>11</td>
  </tr>
  <tr>
    <td>MI</td>
    <td>분</td>
    <td>20</td>
  </tr>
  <tr>
    <td>SS</td>
    <td>초</td>
    <td>30</td>
  </tr>
</table>
<div class = "code">
SELECT SYSDATE
	,TO_CHAR(SYSDATE, 'YYYY')"YYYY"
	,TO_CHAR(SYSDATE, 'MM')"MM"
	,TO_CHAR(SYSDATE, 'DD')"DD"
	,TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')"YYYY-MM-DD HH24:MI:SS"
FROM dual;
--SYSDATE  YYYY     MM   DD   YYYY-MM-DD HH24:MI:SS
---------- -------- ---- ---- --------------------------------------
--21/02/01 2021     02   01   2021-02-01 10:43:00
</div>
--P105퀴즈

<div class = "code">
SELECT studno, name, TO_CHAR(birthday, 'DD-MM-YY')
FROM student
WHERE EXTRACT(MONTH FROM birthday) = 1;
--    STUDNO NAME                      TO_CHAR(BIRTHDAY
------------ ------------------------- ----------------
--      9511 Billy Crystal             23-01-76
--      9514 Bill Murray               20-01-76
--      9712 Sean Connery              05-01-78
</div>
--p106퀴즈

<div class = "code">
SELECT empno, ename, hiredate
FROM emp
WHERE EXTRACT(MONTH FROM hiredate) IN(1,2,3);
--     EMPNO ENAME                HIREDATE
------------ -------------------- --------
--      7499 ALLEN                81/02/20
--      7521 WARD                 81/02/22
--      7934 MILLER               82/01/23
</div>
<a href="#형변환함수" name="TO_CHAR(NUMBER_TO_CHAR)"><h4>TO_CHAR(NUMBER_TO_CHAR)</h4></a><hr>
--TO_CHAR: 숫자 -> 문자
--종류		의미	         예	                      결과
-- 9 | 9의 개수만큼 자릿수 | TO_CHAR(1234,'99999')   | 1234
-- 0 | 빈자리를 0으로 채움 | TO_CHAR(1234,'099999')  | 001234
-- $ | $표시를 붙여서 표시 | TO_CHAR(1234,'$9999')   | $1234
-- . | 소숫점 이하를 표시  | TO_CHAR(1234,'9999.99') | 1234.00
-- , | 천단위 구분을 표시  | TO_CHAR(12345,'99,999') | 12,345

<div class = "code">
SELECT empno, ename, sal, comm, TO_CHAR((sal*12)+comm,'$99,999')"SALARY"
FROM emp
WHERE ename = 'ALLEN';
--     EMPNO ENAME                       SAL       COMM SALARY
------------ -------------------- ---------- ---------- ----------------
--      7499 ALLEN                      1600        300  $19,500
</div>
--108P 퀴즈

<div class = "code">
SELECT empno, ename
	,TO_CHAR(hiredate,'YYYY-MM-DD')"HIREDATE"
	,TO_CHAR(sal*12+comm,'$999,999')"SAL"
	,TO_CHAR((sal*12+comm)*1.15,'$999,999')"15% UP"
FROM emp
WHERE comm IS NOT NULL;
--     EMPNO ENAME                HIREDATE             SAL                15% UP
------------ -------------------- -------------------- ------------------ ------------------
--      7499 ALLEN                1981-02-20             $19,500            $22,425
--      7521 WARD                 1981-02-22             $15,500            $17,825
--      7654 MARTIN               1981-09-28             $16,400            $18,860
--      7844 TURNER               1981-09-08             $18,000            $20,700
</div>
<a href="#형변환함수" name="TO_NUMBER"><h4>TO_NUMBER</h4></a><hr>
--TO_NUMBER: 숫자가 아닌 숫자문자를 숫자로 바꾸어주는 함수

<div class = "code">
SELECT TO_NUMBER('5')
FROM dual;
--TO_NUMBER('5')
----------------
--             5
</div>
<div class = "code">
SELECT ASCII('A')
FROM dual;
--ASCII('A')
------------
--        65
</div>
<a href="#형변환함수" name="TO_DATE"><h4>TO_DATE</h4></a><hr>
--TO_DATE: 날짜가 아닌 날짜처럼 생긴 문자를 날짜로 바꿔주는 함수

<div class = "code">
SELECT TO_DATE('20210201')"date"
FROM dual;
--date
----------
--21/02/01
</div>



<a href="#일반함수" name="NVL"><h4>NVL</h4></a><hr>
--NVL(컬럼,치환값): NULL값을 만나면 치환값을 출력

<div class = "code">
SELECT ename, comm
	,NVL(comm,0)"NVL"
	,comm*10
	,NVL(comm*10,0)"NVL*10"
FROM emp
WHERE deptno = 30;
--ENAME                      COMM        NVL    COMM*10     NVL*10
---------------------- ---------- ---------- ---------- ----------
--ALLEN                       300        300       3000       3000
--WARD                        500        500       5000       5000
--MARTIN                     1400       1400      14000      14000
--BLAKE                                    0                     0
--TURNER                        0          0          0          0
--JAMES                                    0                     0
</div>
--연습

<div class = "code">
SELECT profno, name, pay, NVL(bonus,0), pay*12+NVL(bonus,0)"TOTAL"
FROM professor
WHERE deptno = 201;
--    PROFNO NAME                                            PAY NVL(BONUS,0)      TOTAL
------------ ---------------------------------------- ---------- ------------ ----------
--      4001 Meryl Streep                                    570          130       6970
--      4002 Susan Sarandon                                  330            0       3960
</div>
<a href="#일반함수" name="NVL2"><h4>NVL2</h4></a><hr>
--NVL2(COL1, COL2, COL3): COL1이 NULL값이 아니면 COL2를, NULL이면 COL3를 출력

<div class = "code">
SELECT ename, empno, sal, comm, NVL2(comm,sal*comm,sal*0)"NVL2"
FROM emp
WHERE deptno = 30;
--ENAME                     EMPNO        SAL       COMM       NVL2
---------------------- ---------- ---------- ---------- ----------
--ALLEN                      7499       1600        300     480000
--WARD                       7521       1250        500     625000
--MARTIN                     7654       1250       1400    1750000
--BLAKE                      7698       2850                     0
--TURNER                     7844       1500          0          0
--JAMES                      7900        950                     0
</div>
--113p퀴즈

<div class = "code">
SELECT empno, ename, comm, NVL2(comm,'Exist','NULL')"NVL2"
FROM emp
WHERE deptno = 30;
--     EMPNO ENAME                      COMM NVL2
------------ -------------------- ---------- ----------
--      7499 ALLEN                       300 Exist
--      7521 WARD                        500 Exist
--      7654 MARTIN                     1400 Exist
--      7698 BLAKE                           NULL
--      7844 TURNER                        0 Exist
--      7900 JAMES                           NULL
</div>
<a href="#일반함수" name="DECODE"><h4>DECODE</h4></a><hr>
--DECODE: 자바에서 사용하는 IF문을 오라클로 가져온 함수(오라클에만 있음)

--유형1.
--DECODE(A,B,1,NULL) (단 마지막의 NULL은 생략가능)
-- A가 B일 경우 1을 출력
--DECODE(A,B,1) (단 마지막의 NULL은 생략가능)

<div class = "code">
SELECT deptno, name, DECODE(deptno,101,'Computer Engineering',NULL)
FROM professor;
--    DEPTNO NAME                                     DNAME
------------ ---------------------------------------- ----------------------------------------
--       101 Audie Murphy                             Computer Engineering
--       101 Angela Bassett                           Computer Engineering
--       101 Jessica Lange                            Computer Engineering
--       102 Winona Ryder
--       102 Michelle Pfeiffer
--       102 Whoopi Goldberg
--       103 Emma Thompson
--       103 Julia Roberts
--       103 Sharon Stone
--       201 Meryl Streep
--       201 Susan Sarandon
--       202 Nicole Kidman
--       202 Holly Hunter
--       203 Meg Ryan
--       301 Andie Macdowell
--       301 Jodie Foster
</div>
--유형2. DECODE(A,B,1,2)
--A가 B일 경우 '1'을, 아니면 '2'를 출력

<div class = "code">
SELECT name, DECODE(deptno,101,'Computer Engineering','ETC')"DNAME"
FROM professor;
--NAME                                     DNAME
------------------------------------------ ----------------------------------------
--Audie Murphy                             Computer Engineering
--Angela Bassett                           Computer Engineering
--Jessica Lange                            Computer Engineering
--Winona Ryder                             ETC
--Michelle Pfeiffer                        ETC
--Whoopi Goldberg                          ETC
--Emma Thompson                            ETC
--Julia Roberts                            ETC
--Sharon Stone                             ETC
--Meryl Streep                             ETC
--Susan Sarandon                           ETC
--Nicole Kidman                            ETC
--Holly Hunter                             ETC
--Meg Ryan                                 ETC
--Andie Macdowell                          ETC
--Jodie Foster                             ETC
</div>
--유형3. DECODE(A,B,1,C,2,3)
--IF(A==B) -> 1
--ELSE IF(A==C) -> 2
--ELSE -> 3

<div class = "code">
SELECT name, deptno
	,DECODE(deptno,101,'Computer Engineering'
				  ,102,'Multimedia Engineering'
				  ,103,'Software Engineering'
				  ,'ETC')"DNAME"
FROM professor;
--NAME                                         DEPTNO DNAME
------------------------------------------ ---------- --------------------------------------------
--Audie Murphy                                    101 Computer Engineering
--Angela Bassett                                  101 Computer Engineering
--Jessica Lange                                   101 Computer Engineering
--Winona Ryder                                    102 Multimedia Engineering
--Michelle Pfeiffer                               102 Multimedia Engineering
--Whoopi Goldberg                                 102 Multimedia Engineering
--Emma Thompson                                   103 Software Engineering
--Julia Roberts                                   103 Software Engineering
--Sharon Stone                                    103 Software Engineering
--Meryl Streep                                    201 ETC
--Susan Sarandon                                  201 ETC
--Nicole Kidman                                   202 ETC
--Holly Hunter                                    202 ETC
--Meg Ryan                                        203 ETC
--Andie Macdowell                                 301 ETC
--Jodie Foster                                    301 ETC
</div>
--유형4. DECODE(A,B,DECODE(C,D,1,NULL)) (NULL은 생략가능)
--IF(A==B){
--	IF(C==D){
--		1
--	}
--}

<div class = "code">
SELECT deptno,name
	,DECODE(deptno,101,DECODE(name,'Audie Murphy','BEST!'))"DNAME"
FROM professor;
--    DEPTNO NAME                                     DNAME
------------ ---------------------------------------- ----------
--       101 Audie Murphy                             Best!
--       101 Angela Bassett
--       101 Jessica Lange
--       102 Winona Ryder
--       102 Michelle Pfeiffer
--       102 Whoopi Goldberg
--       103 Emma Thompson
--       103 Julia Roberts
--       103 Sharon Stone
--       201 Meryl Streep
--       201 Susan Sarandon
--       202 Nicole Kidman
--       202 Holly Hunter
--       203 Meg Ryan
--       301 Andie Macdowell
--       301 Jodie Foster
</div>
--유형5.
--DECODE(A,B,DECODE(C,D,'1','2'),'3')
--IF(A==B){
--	IF(C==D){
--		1
--	}ELSE '2'
--}ELSE '3'

<div class = "code">
SELECT deptno,name
	,DECODE(deptno,101,DECODE(name,'Audie Murphy','BEST!','GOOD!'),'NOT MY MAJOR')"DNAME"
FROM professor;
--    DEPTNO NAME                                     DNAME
------------ ---------------------------------------- ------------------------
--       101 Audie Murphy                             BEST!
--       101 Angela Bassett                           GOOD!
--       101 Jessica Lange                            GOOD!
--       102 Winona Ryder                             NOT MY MAJOR
--       102 Michelle Pfeiffer                        NOT MY MAJOR
--       102 Whoopi Goldberg                          NOT MY MAJOR
--       103 Emma Thompson                            NOT MY MAJOR
--       103 Julia Roberts                            NOT MY MAJOR
--       103 Sharon Stone                             NOT MY MAJOR
--       201 Meryl Streep                             NOT MY MAJOR
--       201 Susan Sarandon                           NOT MY MAJOR
--       202 Nicole Kidman                            NOT MY MAJOR
--       202 Holly Hunter                             NOT MY MAJOR
--       203 Meg Ryan                                 NOT MY MAJOR
--       301 Andie Macdowell                          NOT MY MAJOR
--       301 Jodie Foster                             NOT MY MAJOR
</div>
--연습1

<div class = "code">
SELECT name, jumin, DECODE(SUBSTR(jumin,7,1),'1','MAN','WOMEN')"Gender"
FROM student
WHERE deptno1 = 101;
--NAME                 JUMIN                      Gender
---------------------- -------------------------- ----------
--James Seo            7510231901813              MAN
--Billy Crystal        7601232186327              WOMEN
--Richard Dreyfus      7711291186223              MAN
--Danny Devito         7808192157498              WOMEN
</div>
--연습2

<div class = "code">
COL name FOR a20
SELECT name, tel
	,DECODE(SUBSTR(tel,1,INSTR(tel,')')-1),'02','SEOUL'
              ,'031','GYEONGGI'
              ,'051','BUSAN'
              ,'052','ULSAN'
              ,'055','GYEONGNAM'
              ,'ETC'
	)"LOC"
FROM student;
--NAME                 TEL                            LOC
---------------------- ------------------------------ ------------------
--James Seo            055)381-2158                   GYEONGNAM
--Rene Russo           051)426-1700                   BUSAN
--Sandra Bullock       053)266-8947                   ETC
--Demi Moore           02)6255-9875                   SEOUL
--Danny Glover         031)740-6388                   GYEONGGI
--Billy Crystal        055)333-6328                   GYEONGNAM
--Nicholas Cage        051)418-9627                   BUSAN
--Micheal Keaton       051)724-9618                   BUSAN
--Bill Murray          055)296-3784                   GYEONGNAM
--Macaulay Culkin      02)312-9838                    SEOUL
--Richard Dreyfus      02)6788-4861                   SEOUL
--Tim Robbins          055)488-2998                   GYEONGNAM
--Wesley Snipes        053)736-4981                   ETC
--Steve Martin         02)6175-3945                   SEOUL
--Daniel Day-Lewis     051)785-6984                   BUSAN
--Danny Devito         055)278-3649                   GYEONGNAM
--Sean Connery         02)381-5440                    SEOUL
--Christian Slater     031)345-5677                   GYEONGGI
--Charlie Sheen        055)423-9870                   GYEONGNAM
--Anthony Hopkins      02)6122-2345                   SEOUL
</div>

<a href="#일반함수" name="CASE"><h4>CASE</h4></a><hr>
--CASE VS DECODE
--DECODE는 == 조건인 경우
--CASE는 == 조건이 아닌경우

--CASE 조건 WHEN 결과 THEN 출력 END

<div class = "code">
SELECT name, tel
	,CASE(SUBSTR(tel,1,INSTR(tel,')')-1)) WHEN '02' THEN 'SEOUL'
              WHEN '031' THEN 'GYEONGGI'
              WHEN '051' THEN 'BUSAN'
              WHEN '052' THEN 'ULSAN'
              WHEN '055' THEN 'GYEONGNAM'
              ELSE 'ETC'
	END "LOC"
FROM student;
--NAME                 TEL                            LOC
---------------------- ------------------------------ ------------------
--James Seo            055)381-2158                   GYEONGNAM
--Rene Russo           051)426-1700                   BUSAN
--Sandra Bullock       053)266-8947                   ETC
--Demi Moore           02)6255-9875                   SEOUL
--Danny Glover         031)740-6388                   GYEONGGI
--Billy Crystal        055)333-6328                   GYEONGNAM
--Nicholas Cage        051)418-9627                   BUSAN
--Micheal Keaton       051)724-9618                   BUSAN
--Bill Murray          055)296-3784                   GYEONGNAM
--Macaulay Culkin      02)312-9838                    SEOUL
--Richard Dreyfus      02)6788-4861                   SEOUL
--Tim Robbins          055)488-2998                   GYEONGNAM
--Wesley Snipes        053)736-4981                   ETC
--Steve Martin         02)6175-3945                   SEOUL
--Daniel Day-Lewis     051)785-6984                   BUSAN
--Danny Devito         055)278-3649                   GYEONGNAM
--Sean Connery         02)381-5440                    SEOUL
--Christian Slater     031)345-5677                   GYEONGGI
--Charlie Sheen        055)423-9870                   GYEONGNAM
--Anthony Hopkins      02)6122-2345                   SEOUL
</div>
--비교조건이 == 이 아닌경우

<div class = "code">
COL "QUARTER" FOR a10
SELECT name, jumin
	, CASE WHEN SUBSTR(jumin,3,2) BETWEEN '01' AND '03' THEN '1/4'
		   WHEN SUBSTR(jumin,3,2) BETWEEN '04' AND '07' THEN '2/4'
		   WHEN SUBSTR(jumin,3,2) BETWEEN '07' AND '10' THEN '3/4'
		   WHEN SUBSTR(jumin,3,2) BETWEEN '10' AND '12' THEN '4/4'
	END "QUARTER"
FROM student;
--NAME                 JUMIN                      QUARTER
---------------------- -------------------------- ----------
--James Seo            7510231901813              3/4
--Rene Russo           7502241128467              1/4
--Sandra Bullock       7506152123648              2/4
--Demi Moore           7512251063421              4/4
--Danny Glover         7503031639826              1/4
--Billy Crystal        7601232186327              1/4
--Nicholas Cage        7604122298371              2/4
--Micheal Keaton       7609112118379              3/4
--Bill Murray          7601202378641              1/4
--Macaulay Culkin      7610122196482              3/4
--Richard Dreyfus      7711291186223              4/4
--Tim Robbins          7704021358674              2/4
--Wesley Snipes        7709131276431              3/4
--Steve Martin         7702261196365              1/4
--Daniel Day-Lewis     7712141254963              4/4
--Danny Devito         7808192157498              3/4
--Sean Connery         7801051776346              1/4
--Christian Slater     7808091786954              3/4
--Charlie Sheen        7803241981987              1/4
--Anthony Hopkins      7802232116784              1/4
</div>
--123p 퀴즈

<div class = "code">
SELECT empno, ename, sal
	,CASE   WHEN sal BETWEEN 1 AND 1000 THEN 'LEVEL 1'
			WHEN sal BETWEEN 1001 AND 2000 THEN 'LEVEL 2'
			WHEN sal BETWEEN 2001 AND 3000 THEN 'LEVEL 3'
			WHEN sal BETWEEN 3001 AND 4000 THEN 'LEVEL 4'
			WHEN sal > 4001 THEN 'LEVEL 5'
	END "LEVEL"
FROM emp
ORDER BY 4 DESC;
--     EMPNO ENAME                       SAL LEVEL
------------ -------------------- ---------- --------------
--      7839 KING                       5000 LEVEL 5
--      7698 BLAKE                      2850 LEVEL 3
--      7902 FORD                       3000 LEVEL 3
--      7782 CLARK                      2450 LEVEL 3
--      7566 JONES                      2975 LEVEL 3
--      7934 MILLER                     1300 LEVEL 2
--      7654 MARTIN                     1250 LEVEL 2
--      7844 TURNER                     1500 LEVEL 2
--      7521 WARD                       1250 LEVEL 2
--      7499 ALLEN                      1600 LEVEL 2
--      7900 JAMES                       950 LEVEL 1
--      7369 SMITH                       800 LEVEL 1
</div>
<a href="#정규식" name="META_CHARACTER"><h4>META_CHARACTER</h4></a><hr>
--^ : 문자열 시작
--$ : 문자열 종료
--. : 임의의 문자 [단 ‘'는 넣을 수 없습니다.]
--* : 앞 문자가 0개 이상의 개수가 존재할 수 있습니다.
--+ : 앞 문자가 1개 이상의 개수가 존재할 수 있습니다.
--? : 앞 문자가 없거나 하나 있을 수 있습니다.
--[] : 문자의 집합이나 범위를 표현합니다. -기호를 통해 범위를 나타낼 수 있습니다. ^가 존재하면 not을 나타냅니다.
--{} : 횟수 또는 범위를 나타냅니다.
--() : 괄호안의 문자를 하나의 문자로 인식합니다.
--| : 패턴을 OR 연산을 수행할 때 사용합니다.
--\s : 공백 문자
--\S : 공백 문자가 아닌 나머지 문자
--\w : 알파벳이나 문자
--\W : 알파벳이나 숫자를 제외한 문자
--\d : [0-9] 숫자
--\D : 숫자를 제외한 모든 문자
--(?i) : 대소문자를 구분하지 않습니다.
<a href="#정규식" name="REGEXP_LIKE"><h4>REGEXP_LIKE</h4></a><hr>
-- REGEXP_LIKE: LIKE연산과 유사한 정규식

--유형 1. 특정문자가 들어있는 데이터 출력
--소문자가 들어있는 텍스트 추출('[a-z]')
--대문자가 들어있는 텍스트 추출('[A-Z]')
--영문자가 들어있는 텍스트 추출('[a-zA-Z]')

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'[a-zA-Z]');
--TEXT
----------------------
--ABC123
--ABC 123
--ABC  123
--abc 123
--abc  123
--a1b2c3
--aabbcc123
--123abc
--abc
</div>
--유형2. 공백을 포함(하나 이상)하는 데이터 출력
--영문자로시작, 공백이 하나이상 있는 행 출력

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'[a-zA-Z] ');
--TEXT
----------------------
--ABC 123
--ABC  123
--abc 123
--abc  123
</div>
--유형3. 공백을 하나만 포함하는 데이터 출력
--영문자로시작, 공백이 하나, 숫자가 있는 행 출력

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'[a-zA-Z] [0-9]');
--TEXT
----------------------
--ABC 123
--abc 123
</div>
--유형4. 반복하는 문자를 가지는 데이터 출력
-- {} 횟수 또는 범위를 나타냅니다.
--영문대문자 3번반복하는 행 출력

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'[A-Z]{3}');
--TEXT
----------------------
--ABC123
--ABC 123
--ABC  123
</div>
--유형5. 특정 문자로 시작하는 데이터 출력
-- ^ 문자열 시작
--영문자로 시작하는 데이터 출력('^[a-zA-Z]')
--숫자와 대문자로 시작하는 데이터 출력('^[0-9A-Z]')

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'^[a-zA-Z]');
--TEXT
----------------------
--ABC123
--ABC 123
--ABC  123
--abc 123
--abc  123
--a1b2c3
--aabbcc123
--abc
</div>
--유형6. 두 개 이상의 정규식 조건을 지정하여 데이터 출력
-- | 패턴은 OR 연산을 수행할 때 사용합니다.
--영문소문자로 시작하거나 OR 숫자로 시작하는 데이터 출력

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'^[a-z]|^[0-9]');
--TEXT
----------------------
--abc 123
--abc  123
--a1b2c3
--aabbcc123
--123123
--123abc
--abc
</div>
--유형7. 특정 문자들로 시작하는 데이터 출력
--id가 MO or MA로 시작하는 데이터 출력
-- () 괄호안의 문자를 하나의 문자로 인식합니다.

<div class = "code">
SELECT name, id
FROM student
WHERE REGEXP_LIKE(id,'^M(o|a)');
--NAME                                                         ID
-------------------------------------------------------------- ----------------------------------------
--Demi Moore                                                   Moore
--Steve Martin                                                 Martin
</div>
--유형8. 특정문자로 끝나는 데이터 출력
-- $ 문자열 종료
--영문자로 끝나는 데이터 출력

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'[a-zA-z]$');
--TEXT
----------------------
--123abc
--abc
</div>
--유형9. 특정문자를 제외한 데이터 출력
-- [^] 해당문자에 해당하지 않는 한 문자
-- 소문자로 시작하지 않는 데이터 출력

<div class = "code">
SELECT *
FROM t_reg
WHERE REGEXP_LIKE(text,'^[^a-z]');
--TEXT
----------------------
--ABC123
--ABC 123
--ABC  123
--?/!@#$*&
--\~*().,
--123123
--123abc
</div>
--유형10. 특수문자를 사용한 정규식으로 데이터 출력
--지역번호 2자리, 국번 4자리가 나오는 값을 출력
--괄호는 역슬래쉬(\)를 붙혀 사용한다.

<div class = "code">
SELECT name, tel
FROM student
WHERE REGEXP_LIKE(tel,'^[0-9]{2}\)[0-9]{4}');
--NAME                                                         TEL
-------------------------------------------------------------- ------------------------------
--Demi Moore                                                   02)6255-9875
--Richard Dreyfus                                              02)6788-4861
--Steve Martin                                                 02)6175-3945
--Anthony Hopkins                                              02)6122-2345
</div>
--유형11. 특정문자가 몇 번째에 들어있는지 정규식으로 지정하여 데이터 출력
-- . 임의의 문자 [단 '는 넣을 수 없습니다.]
--id에서 네 번째 글자가 'r'인 데이터 출력

<div class = "code">
SELECT name, id
FROM student
WHERE REGEXP_LIKE(id,'^...r');
--NAME                                                         ID
-------------------------------------------------------------- ----------------------------------------
--James Seo                                                    75true
--Demi Moore                                                   Moore
--Bill Murray                                                  Murray
</div>
--유형12. 특정문자를 제외한 데이터출력2
--not을 붙히면 서술한 정규식의 데이터는 제외하고 출력한다는 것

<div class = "code">
SELECT *
FROM t_reg
WHERE NOT REGEXP_LIKE(text,'[a-zA-Z]');
--TEXT
----------------------
--?/!@#$*&
--\~*().,
--123123
</div>
<a href="#정규식" name="REGEXP_REPLACE"><h4>REGEXP_REPLACE</h4></a><hr>
--REGEXP_REPLACE: 정규식을 검색하여 대체 문자열로 변경
--숫자를 찾아서 * 로 치환

<div class = "code">
COL "REGEXP_REPLACE" FOR a15
SELECT text
	,REGEXP_REPLACE(text,'[0-9]','*') "REGEXP_REPLACE"
FROM t_reg;
--TEXT                 REGEXP_REPLACE
---------------------- ---------------
--ABC123               ABC***
--ABC 123              ABC ***
--ABC  123             ABC  ***
--abc 123              abc ***
--abc  123             abc  ***
--a1b2c3               a*b*c*
--aabbcc123            aabbcc***
--?/!@#$*&             ?/!@#$*&
--\~*().,              \~*().,
--123123               ******
--123abc               ***abc
--abc                  abc
</div>
<a href="#정규식" name="REGEXP_SUBSTR"><h4>REGEXP_SUBSTR</h4></a><hr>
-- REGEXP_SUBSTR: 정규식을 검색하여 문자추출

<div class = "code">
SELECT 'ABC* *DEF $GHI %KLM'"SENTENCE"
	,REGEXP_SUBSTR('ABC* *DEF $GHI %KLM','[^ ]+[DEF]')"EXTRACT"
FROM dual;
--SENTENCE                               EXTRACT
---------------------------------------- --------
--ABC* *DEF $GHI %KLM                    *DEF
</div>
--홈페이지 주소에서 'http://' 부분 제거, '.'으로 구분되는 필드 3~4개 출력
-- ? 앞 문자가 없거나 하나 있을 수 있습니다.

<div class = "code">
COL name FOR a20
COL hpage FOR a30
COL "URL" FOR a20
SELECT name, hpage
	,LTRIM(REGEXP_SUBSTR(hpage,'/([A-Za-z0-9]+\.?){3,4}'),'/')"URL"
FROM professor
WHERE hpage IS NOT NULL;
--NAME                 HPAGE                          URL
---------------------- ------------------------------ --------------------
--Audie Murphy         http://www.abc.net             www.abc.net
--Angela Bassett       http://www.abc.net             www.abc.net
--Jessica Lange        http://www.power.com           www.power.com
--Michelle Pfeiffer    http://num1.naver.com          num1.naver.com
</div>
<a href="#정규식" name="REGEXP_COUNT"><h4>REGEXP_COUNT</h4></a><hr>
--REGEXP_COUNT(11g): 정규식을 검색하여 발견한 횟수
--REGEXP_COUNT (source_char, pattern [, position [, match_param]])

<div class = "code">
SELECT text,
	REGEXP_COUNT(text,'a')"COUNT"
FROM t_reg;
--TEXT                      COUNT
---------------------- ----------
--ABC123                        0
--ABC 123                       0
--ABC  123                      0
--abc 123                       1
--abc  123                      1
--a1b2c3                        1
--aabbcc123                     2
--?/!@#$*&                      0
--\~*().,                       0
--123123                        0
--123abc                        1
--abc                           1
</div>
<a href="#그룹함수" name="그룹함수의_종류"><h4>그룹함수의_종류</h4></a><hr>
<table>
  <tr>
    <th>함수명</th>
    <th>의미</th>
  </tr>
  <tr>
    <td>COUNT</td>
    <td>입력데이터의 총 건수 출력</td>
  </tr>
  <tr>
    <td>SUM</td>
    <td>입력데이터의 합계</td>
  </tr>
  <tr>
    <td>AVG</td>
    <td>입력데이터의 평균</td>
  </tr>
  <tr>
    <td>MAX</td>
    <td>입력데이터의 최대값</td>
  </tr>
  <tr>
    <td>MIN</td>
    <td>입력데이터의 최소값</td>
  </tr>
  <tr>
    <td>STDDEV</td>
    <td>입력데이터의 표준편차</td>
  </tr>
  <tr>
    <td>VARIANCE</td>
    <td>입력데이터의 분산</td>
  </tr>
  <tr>
    <td>ROLLUP</td>
    <td>입력데이터의 소계를 계산해 출력</td>
  </tr>
  <tr>
    <td>CUBE</td>
    <td>입력데이터의 소계 및 전체 총계를 계산</td>
  </tr>
  <tr>
    <td>GROUPINGSET</td>
    <td>한 번의 쿼리로 여러개의 함수들을 그룹으로 수행</td>
  </tr>
  <tr>
    <td>LISTAGG</td>
    <td>여러 ROW를 하나의 ROW에 합쳐서 출력(DATA 제한있음-XMLAGG를 사용하자)</td>
  </tr>
  <tr>
    <td>XMLAGG</td>
    <td>여러 ROW를 하나의 ROW에 합쳐서 출력(DATA 제한없음)</td>
  </tr>
  <tr>
    <td>PIVOT</td>
    <td>열을 행으로, 행을 열로 출력</td>
  </tr>
  <tr>
    <td>LAG</td>
    <td>이전 행 값을 가져올 때 사용(앞뒤 비교해서 보여줄 때 사용)</td>
  </tr>
  <tr>
    <td>LEAD</td>
    <td>이후 행 값을 가져올 때 사용(앞뒤 비교해서 보여줄 때 사용)</td>
  </tr>
  <tr>
    <td>RANK</td>
    <td>순위 출력함수(ex.2위 3개 뒤에는 5위)</td>
  </tr>
  <tr>
    <td>DENSE_RANK</td>
    <td>순위 출력함수(ex.2위 3개 뒤에는 3위)</td>
  </tr>
  <tr>
    <td>누계집계하기</td>
    <td></td>
  </tr>
</table>
<a href="#그룹함수" name="COUNT"><h4>COUNT</h4></a><hr>
--COUNT:입력데이터의 총 건수 출력
--복수행 함수에 *를 사용하면 NULL을 포함
--복수행 함수에 이름을 쓰면 NULL을 포함하지 않음

<div class = "code">
SELECT COUNT(*), COUNT(comm)
FROM emp;
--  COUNT(*) COUNT(COMM)
------------ -----------
--        12           4
</div>
<a href="#그룹함수" name="SUM"><h4>SUM</h4></a><hr>
--SUM:입력데이터의 합계

<div class = "code">
SELECT SUM(comm)"SUM_comm"
	,COUNT(comm)"COUNT_comm"
FROM emp;
--  SUM_comm COUNT_comm
------------ ----------
--      2200          4
</div>
<a href="#그룹함수" name="AVG"><h4>AVG</h4></a><hr>
--AVG: 입력데이터의 평균
--전체인원에 대한 평균을 구하기 위해서는

<div class = "code">
SELECT AVG(comm)"WRONG"
	,AVG(NVL(comm,0))"CORRECT"
	,ROUND(AVG(NVL(comm,0)),2)"ROUND"
FROM emp;
--     WRONG    CORRECT      ROUND
------------ ---------- ----------
--       550 183.333333     183.33
</div>
<a href="#그룹함수" name="MAX | MIN"><h4>MAX | MIN</h4></a><hr>
--MAX | MIN: 입력데이터의 최대값&최소값
--내부적으로 ORDER BY를 돌려서 값을 구함

<div class = "code">
SELECT MAX(sal),MIN(sal)
FROM emp;
--  MAX(SAL)   MIN(SAL)
------------ ----------
--      5000        800
</div>
<a href="#그룹함수" name="VARIANCE | STDDEV"><h4>VARIANCE | STDDEV</h4></a><hr>
--VARIANCE: 입력데이터의 분산
--분산이란 평균에 대한 편차제곱의 평균을 구한 것이다.
--STDDEV: 입력데이터의 표준편차
--표준편차란 분산의 양의 제곱근으로 정의된다.

<div class = "code">
SELECT VARIANCE(sal),STDDEV(sal),AVG(NVL(sal,0))
FROM emp;
--VARIANCE(SAL) STDDEV(SAL) AVG(NVL(SAL,0))
--------------- ----------- ---------------
--   1488347.54   1219.9785      2077.08333
</div>
<a href="#그룹함수" name="GROUP_BY"><h4>GROUP_BY</h4></a><hr>
--GROUP_BY: 특정조건으로 세부적인 그룹을 지정
--원리: GROUP BY 뒤에오는 컬럼값을 기준으로 먼저 데이터를 모아놓고,
--SELECT절에 있는 그룹함수를 적용.

--GROUP BY 주의사항
--SELECT절에 사용된 그룹함수 이외의 칼럼이나 표현식은 GROUP BY절에 사용되어야 한다.
--GROUP BY절에는 반드시 컬럼명이 사용되어야 한다.

--GROUP BY를 통해 부서별 평균을 출력

<div class = "code">
SELECT deptno,AVG(NVL(sal,0))"AVERAGE"
FROM emp
GROUP BY deptno;
--    DEPTNO    AVERAGE
------------ ----------
--        30 1566.66667
--        20 2258.33333
--        10 2916.66667
</div>
--칼럼 2개(부서, 직급)로 GROUP BY하여 평균을 출력

<div class = "code">
SELECT deptno, job, AVG(NVL(sal,0))"AVERAGE"
FROM emp
GROUP BY deptno, job
ORDER BY 1,3 DESC;
--    DEPTNO JOB                   AVERAGE
------------ ------------------ ----------
--        10 PRESIDENT                5000
--        10 MANAGER                  2450
--        10 CLERK                    1300
--        20 ANALYST                  3000
--        20 MANAGER                  2975
--        20 CLERK                     800
--        30 MANAGER                  2850
--        30 SALESMAN                 1400
--        30 CLERK                     950
</div>
<a href="#그룹함수" name="HAVING"><h4>HAVING</h4></a><hr>
--HAVING: 그룹핑한 조건으로 검색
--HAVING 조건으로 부서평균월급이 2000을 넘을 것을 지정

<div class = "code">
SELECT deptno, AVG(NVL(sal,0))"AVERAGE"
FROM emp
GROUP BY deptno
HAVING AVG(NVL(sal,0)) > 2000
ORDER BY 1;
--    DEPTNO    AVERAGE
------------ ----------
--        10 2916.66667
--        20 2258.33333
</div>
<a href="#그룹함수" name="ROLLUP"><h4>ROLLUP</h4></a><hr>
--ROLLUP: 입력데이터의 소계를 계산해 출력
--ROLLUP에 지정된 컬럼들은 소계의 기준이 되는 컬럼이다.
--N+1 LEVEL에 소계출력

--유형1. 부서별, 직급별 평균과 전체 평균을 출력
--ROLLUP에 deptno,job 두 개를 넣었으므로 3개의 LEVEL이 나온다.
--부서별 평균, 직급별 평균, 전체 평균 3개

<div class = "code">
SELECT deptno, job, AVG(NVL(sal,0))"AVG", COUNT(*)"THE NUMBER OF EMPLOYEE"
FROM emp
GROUP BY ROLLUP(deptno,job);
--    DEPTNO JOB                       AVG THE NUMBER OF EMPLOYEE
------------ ------------------ ---------- ----------------------
--        10 CLERK                    1300                      1
--        10 MANAGER                  2450                      1
--        10 PRESIDENT                5000                      1
--        10                    2916.66667                      3
--        20 CLERK                     800                      1
--        20 ANALYST                  3000                      1
--        20 MANAGER                  2975                      1
--        20                    2258.33333                      3
--        30 CLERK                     950                      1
--        30 MANAGER                  2850                      1
--        30 SALESMAN                 1400                      4
--        30                    1566.66667                      6
--                              2077.08333                     12
</div>
--유형2. 부서별 직급별로 월급의 평균과 전체 평균을 출력하되,
--월급이 1000달러가 넘는 직원만 통계에 넣어서 계산할 것

<div class = "code">
SELECT job, AVG(NVL(sal,0)), COUNT(*)
FROM emp
WHERE sal > 1000
GROUP BY ROLLUP(job);
--JOB                AVG(NVL(SAL,0))   COUNT(*)
-------------------- --------------- ----------
--ANALYST                       3000          1
--CLERK                         1300          1
--MANAGER                 2758.33333          3
--PRESIDENT                     5000          1
--SALESMAN                      1400          4
--                            2317.5         10
</div>
<a href="#그룹함수" name="CUBE"><h4>CUBE</h4></a><hr>
--CUBE: 입력데이터의 소계 및 전체 총계를 계산
--GROUP BY CUBE(컬럼1, 컬럼2, ....)
--2^n LEVEL의 소계출력
--모든 경우에 대한 소계를 구하기 때문에 컬럼의 순서는 중요하지 않음

--유형1. 부서별, 직급별로 월급의 평균과 전체평균을 구하시오(여기까지는 ROLLUP과 동일)
--또한 부서에 상관없이 직급별로도 평균을 내시오(CUBE에서 추가되는 부분)

<div class = "code">
SELECT deptno, job, ROUND(AVG(NVL(sal,0)),1)"AVERAGE", COUNT(*)
FROM emp
GROUP BY CUBE(deptno, job)
ORDER BY deptno, job;
--    DEPTNO JOB                   AVERAGE   COUNT(*)
------------ ------------------ ---------- ----------
--        10 CLERK                    1300          1
--        10 MANAGER                  2450          1
--        10 PRESIDENT                5000          1
--        10                        2916.7          3
--        20 ANALYST                  3000          1
--        20 CLERK                     800          1
--        20 MANAGER                  2975          1
--        20                        2258.3          3
--        30 CLERK                     950          1
--        30 MANAGER                  2850          1
--        30 SALESMAN                 1400          4
--        30                        1566.7          6
--           ANALYST                  3000          1
--           CLERK                  1016.7          3
--           MANAGER                2758.3          3
--           PRESIDENT                5000          1
--           SALESMAN                 1400          4
--                                  2077.1         12
</div>
--유형2.
--CUBE함수를 이용하여 부서별, 직급별 평균을 출력
--직급이 사장인 데이터는 제외할 것
--부서와 직급으로 오름차순으로 정렬할 것

<div class = "code">
  SELECT deptno, job, ROUND(AVG(NVL(sal,0)))"AVG"
  FROM emp
  WHERE job != 'PRESIDENT'
  GROUP BY CUBE(deptno, job)
  ORDER BY deptno, job;
  --    DEPTNO JOB                       AVG
  ------------ ------------------ ----------
  --        10 CLERK                    1300
  --        10 MANAGER                  2450
  --        10                          1875
  --        20 ANALYST                  3000
  --        20 CLERK                     800
  --        20 MANAGER                  2975
  --        20                          2258
  --        30 CLERK                     950
  --        30 MANAGER                  2850
  --        30 SALESMAN                 1400
  --        30                          1567
  --           ANALYST                  3000
  --           CLERK                    1017
  --           MANAGER                  2758
  --           SALESMAN                 1400
  --                                    1811
</div>
<a href="#그룹함수" name="GROUPING_SETS"><h4>GROUPING_SETS</h4></a><hr>
--GROUPING_SETS: 그룹핑 조건이 여러개일 경우 유용하게 사용가능
--GROUPING SETS(expr1,expr2,expr3......)

--학년별로 인원수, 키 평균, 몸무게 평균을 구함
--이 경우 GROUP이 하나이기 때문에 GROUP BY로 가능

<div class = "code">
SELECT grade
	,COUNT(*)"NUMBER"
	,ROUND(AVG(NVL(height,0)))"AVG_HEIGHT"
	,ROUND(AVG(NVL(weight,0)))"AVG_WEIGHT"
FROM student
GROUP BY grade;
--     GRADE     NUMBER AVG_HEIGHT AVG_WEIGHT
------------ ---------- ---------- ----------
--         1          5        170         62
--         2          5        176         67
--         4          5        176         68
--         3          5        167         51
</div>
--학년별 + 학과별로 인원수, 키 평균, 몸무게 평균을 구할경우
--GROUPING SETS을 이용하면 한 테이블에 간단하게 출력가능

<div class = "code">
SELECT grade, deptno1
	,COUNT(*)"NUMBER"
	,ROUND(AVG(NVL(height,0)))"AVG_HEIGHT"
	,ROUND(AVG(NVL(weight,0)))"AVG_WEIGHT"
FROM student
GROUP BY GROUPING SETS(grade, deptno1);
--     GRADE    DEPTNO1     NUMBER AVG_HEIGHT AVG_WEIGHT
------------ ---------- ---------- ---------- ----------
--                  102          4        171         64
--                  201          6        173         67
--                  301          2        172         60
--                  101          4        172         60
--                  202          2        180         63
--                  103          2        166         52
--         1                     5        170         62
--         2                     5        176         67
--         4                     5        176         68
--         3                     5        167         51
</div>
<a href="#그룹함수" name="PLAN"><h4>PLAN</h4></a><hr>
1. explain plan for 입력
2. 수행할 쿼리 입력
3. col plan_table_output format a80 SELECT * FROM table(dbms_xplan.display); 입력

1. ROLLUP을 UNION ALL로 구현했을 때의 PLAN
--세부 쿼리부터 실행 후 큰 단위로 합쳐나가는 방식(UNION ALL)으로 실행될 것을 알 수 있음
--EMP 테이블이 3번 조회 되었음.

<div class = "code">
--PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------
--Plan hash value: 3259471421
--                                                                             실행순서
-------------------------------------------------------------------------------
--| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT     |      |    15 |   190 |    12  (25)| 00:00:01 |   8
--|   1 |  SORT ORDER BY       |      |    15 |   190 |    11  (73)| 00:00:01 |   7
--|   2 |   UNION-ALL          |      |       |       |            |          |   6
--|   3 |    HASH GROUP BY     |      |    11 |   165 |     4  (25)| 00:00:01 |   2
--|   4 |     TABLE ACCESS FULL| EMP  |    12 |   180 |     3   (0)| 00:00:01 |   1
--|   5 |    HASH GROUP BY     |      |     3 |    21 |     4  (25)| 00:00:01 |   4
--|   6 |     TABLE ACCESS FULL| EMP  |    12 |    84 |     3   (0)| 00:00:01 |   3
--|   7 |    SORT AGGREGATE    |      |     1 |     4 |            |          |   6
--|   8 |     TABLE ACCESS FULL| EMP  |    12 |    48 |     3   (0)| 00:00:01 |   5
-------------------------------------------------------------------------------
</div>
2. ROLLUP 함수를 사용하였을 때의 PLAN
--UNION ALL 방식보다 더 적은 수행단계를 가짐
--EMP테이블은 1번 조회되었음
--PLAN을 통해 UNION ALL보다 ROLLUP이 실행속도가 빠를 것임을 알 수 있음

<div class = "code">
--PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------
--Plan hash value: 52302870
--                                                                            실행순서
-------------------------------------------------------------------------------
--| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT     |      |    11 |   165 |     4  (25)| 00:00:01 |   3
--|   1 |  SORT GROUP BY ROLLUP|      |    11 |   165 |     4  (25)| 00:00:01 |   2
--|   2 |   TABLE ACCESS FULL  | EMP  |    12 |   180 |     3   (0)| 00:00:01 |   1
-------------------------------------------------------------------------------
</div>
<a href="#그룹함수" name="LISTAGG"><h4>LISTAGG</h4></a><hr>
--LISTAGG: 여러 ROW데이터를 하나의 ROW에서 합쳐서 보여주는 함수
--RETURN 데이터 4000BYTE를 넘으면 안됨
--LISTAGG(컬럼,'구분자') WITHIN GROUP (ORDER BY 컬럼2)

--부서별 직원의 이름을 하나의 ROW로 출력

<div class = "code">
COL "LISTAGG" FOR A50
SELECT deptno, LISTAGG(ename,'-') WITHIN GROUP(ORDER BY hiredate)"LISTAGG"
FROM emp
GROUP BY deptno;
--    DEPTNO LISTAGG
------------ --------------------------------------------------
--        10 CLARK-KING-MILLER
--        20 SMITH-JONES-FORD
--        30 ALLEN-WARD-BLAKE-TURNER-MARTIN-JAMES
</div>
<a href="#그룹함수" name="XMLAGG"><h4>XMLAGG</h4></a><hr>
--XMLAGG
--LISTAGG는 4000BYTE를 넘을경우 오류가 발생한다.
--이 경우 사용하는 것이 XMLAGG
--리턴타입이 VARCHAR2인지 CLOB인지에 따라 형태가 달라지므로 주의

--유형1. 부서별로 직원들의 이름을 하나의 ROW로 출력. 순서는 입사일
--XMLELEMENT(태그,'구분자',컬럼): 컬럼의 데이터에 태그를 붙혀 XML데이터로 만들어줌
--EXTRACT('//text()'): 텍스트로 추출
--getStringVal(): 문자열로 get함
--SUBSTR: 맨 앞의 쉼표를 제외한 문자열을 출력

<div class = "code">
COL "XMLAGG" FOR A100
SELECT deptno
	,SUBSTR(
		XMLAGG(XMLELEMENT(X,',',ename) ORDER BY hiredate).EXTRACT('//text()').getStringVal()
	,2)"XMLAGG"
FROM emp
GROUP BY deptno;
--    DEPTNO XMLAGG
------------ ----------------------------------------------------------------------------------------------------
--        10 CLARK,KING,MILLER
--        20 SMITH,JONES,FORD
--        30 ALLEN,WARD,BLAKE,TURNER,MARTIN,JAMES
</div>
--유형2. 직업별로 직원들의 이름을 하나의 ROW로 출력. 순서는 월급순

--1. 직원들의 이름 앞뒤로 태그를 붙혀줌
--XMLELEMENT(태그,'구분자',컬럼): 컬럼의 데이터에 태그를 붙혀 XML데이터로 만들어줌

<div class = "code">
COL "NAME" FOR A50
SELECT job, XMLELEMENT(NAME,'-',ename)"NAME"
FROM emp;
--JOB                NAME
-------------------- --------------------------------------------------
--CLERK              <NAME>-SMITH</NAME>
--SALESMAN           <NAME>-ALLEN</NAME>
--SALESMAN           <NAME>-WARD</NAME>
--MANAGER            <NAME>-JONES</NAME>
--SALESMAN           <NAME>-MARTIN</NAME>
--MANAGER            <NAME>-BLAKE</NAME>
--MANAGER            <NAME>-CLARK</NAME>
--PRESIDENT          <NAME>-KING</NAME>
--SALESMAN           <NAME>-TURNER</NAME>
--CLERK              <NAME>-JAMES</NAME>
--ANALYST            <NAME>-FORD</NAME>
--CLERK              <NAME>-MILLER</NAME>
</div>
--2. 직업별로 직원들의 이름을 하나의 ROW로 출력
--XMLAGG(컬럼1 ORDER BY 컬럼2): 컬럼1을 컬럼2의 순서로 정렬하여 하나의 ROW에 출력

<div class = "code">
COL "NAME" FOR A80
SELECT job, XMLAGG(XMLELEMENT(NAME,'-',ename)ORDER BY sal)"NAME"
FROM emp
GROUP BY job;
--JOB                NAME
-------------------- --------------------------------------------------------------------------------
--ANALYST            <NAME>-FORD</NAME>
--CLERK              <NAME>-SMITH</NAME><NAME>-JAMES</NAME><NAME>-MILLER</NAME>
--MANAGER            <NAME>-CLARK</NAME><NAME>-BLAKE</NAME><NAME>-JONES</NAME>
--PRESIDENT          <NAME>-KING</NAME>
--SALESMAN           <NAME>-WARD</NAME><NAME>-MARTIN</NAME><NAME>-TURNER</NAME><NAME>-ALLEN</NAME>
</div>
--3. 태그를 제외한 데이터만 뽑아서 출력
--EXTRACT('//text()')

<div class = "code">
COL "NAME" FOR A50
SELECT job, XMLAGG(XMLELEMENT(NAME,'-',ename)ORDER BY sal).EXTRACT('//text()')"NAME"
FROM emp
GROUP BY job;
--JOB                NAME
-------------------- --------------------------------------------------
--ANALYST            -FORD
--CLERK              -SMITH-JAMES-MILLER
--MANAGER            -CLARK-BLAKE-JONES
--PRESIDENT          -KING
--SALESMAN           -WARD-MARTIN-TURNER-ALLEN
</div>
--4. 맨 앞의 구분자 - 를제거
--getStringVal(): 문자열로 받음
--SUBSTR: 맨 앞의 - 구분자를 제외한 문자열을 출력

<div class = "code">
COL "NAME" FOR A50
SELECT job
	, SUBSTR(
		XMLAGG(XMLELEMENT(NAME,'-',ename)ORDER BY sal).EXTRACT('//text()').getStringVal()
	,2)"NAME"
FROM emp
GROUP BY job;
--JOB                NAME
-------------------- --------------------------------------------------
--ANALYST            FORD
--CLERK              SMITH-JAMES-MILLER
--MANAGER            CLARK-BLAKE-JONES
--PRESIDENT          KING
--SALESMAN           WARD-MARTIN-TURNER-ALLEN
</div>
<a href="#그룹함수" name="UNPIVOT"><h4>UNPIVOT</h4></a><hr>
--UNPIVOT
--PIVOT된 결과를 되돌리는 기능이 아닌 합쳐있는 것을 단지 풀어서 보여주는 역할

--PIVOT된 테이블 unpivot

<div class = "code">
--   DEPTNO      CLERK   SALESMAN  PRESIDENT    MANAGER    ANALYST
----------- ---------- ---------- ---------- ---------- ----------
--       10          1          0          1          1          0
--       20          1          0          0          1          1
--       30          1          4          0          1          0
</div>
--위의 테이블을 UNPIVOT
--PIVOT된 결과를 되돌리는 기능이 아닌 합쳐있는 것을 단지 풀어서 보여주는 역할

<div class = "code">
SELECT * FROM unpivot
UNPIVOT(
	empno FOR job IN(
		CLERK,SALESMAN,PRESIDENT,MANAGER,ANALYST
	)
);
--    DEPTNO JOB                     EMPNO
------------ ------------------ ----------
--        10 CLERK                       1
--        10 SALESMAN                    0
--        10 PRESIDENT                   1
--        10 MANAGER                     1
--        10 ANALYST                     0
--        20 CLERK                       1
--        20 SALESMAN                    0
--        20 PRESIDENT                   0
--        20 MANAGER                     1
--        20 ANALYST                     1
--        30 CLERK                       1
--        30 SALESMAN                    4
--        30 PRESIDENT                   0
--        30 MANAGER                     1
--        30 ANALYST                     0
</div>
<a href="#그룹함수" name="LAG"><h4>LAG</h4></a><hr>
--LAG: 이전 행 값을 가져올 때 사용
--LAG(출력할 컬럼명,OFFSET,기본출력값)
--OVER(Query_partition구문,ORDER BY 정렬할 컬럼)

<div class = "code">
SELECT ename
	,hiredate
	,sal
	,LAG(sal,3,999) OVER(ORDER BY hiredate)"LAG"
FROM emp;
--ENAME                HIREDATE        SAL        LAG
---------------------- -------- ---------- ----------
--SMITH                80/12/17        800        999
--ALLEN                81/02/20       1600        999
--WARD                 81/02/22       1250        999
--JONES                81/04/02       2975        800
--BLAKE                81/05/01       2850       1600
--CLARK                81/06/09       2450       1250
--TURNER               81/09/08       1500       2975
--MARTIN               81/09/28       1250       2850
--KING                 81/11/17       5000       2450
--JAMES                81/12/03        950       1500
--FORD                 81/12/03       3000       1250
--MILLER               82/01/23       1300       5000
</div>
<a href="#그룹함수" name="LEAD"><h4>LEAD</h4></a><hr>
--LEAD: 이후 행의 값을 가져옴
--LEAD(출력할 컬럼명,OFFSET,기본출력값)
--OVER(Query_partition구문,ORDER BY 정렬할 컬럼)
--OFFSET은 4번째 이후로 설정
--기본값은 5609

<div class = "code">
SELECT ename
	,hiredate
	,sal
	,LEAD(sal,4,5609) OVER(ORDER BY hiredate)"LEAD"
FROM emp;
--ENAME                HIREDATE        SAL       LEAD
---------------------- -------- ---------- ----------
--SMITH                80/12/17        800       2850
--ALLEN                81/02/20       1600       2450
--WARD                 81/02/22       1250       1500
--JONES                81/04/02       2975       1250
--BLAKE                81/05/01       2850       5000
--CLARK                81/06/09       2450        950
--TURNER               81/09/08       1500       3000
--MARTIN               81/09/28       1250       1300
--KING                 81/11/17       5000       5609
--JAMES                81/12/03        950       5609
--FORD                 81/12/03       3000       5609
--MILLER               82/01/23       1300       5609
</div>
<a href="#그룹함수" name="RANK"><h4>RANK</h4></a><hr>
--RANK: 특정데이터의 순위를 출력
--RANK(조건값) WITHIN GROUP (ORDER BY 조건값 컬럼명 [ASC | DESC] )

<div class = "code">
SELECT RANK('SMITH') WITHIN GROUP (ORDER BY ename)"RANK"
FROM emp
ORDER BY ename;
--      RANK
------------
--        10
</div>
<a href="#그룹함수" name="RANK_OVER/DENSE_RANK/ROW_NUMBER"><h4>RANK_OVER / DENSE_RANK / ROW_NUMBER</h4></a><hr>
--A > B1,B2,B3 > C
--RANK_OVER:  1위 A | 2위 B1,B2,B3 | 5위 C
--DENSE_RANK: 1위 A | 2위 B1,B2,B3 | 3위 C
--ROW_NUMBER: 1위 A | 2위 B1       | 3위 B2   | 4위 B3   | 5위 C
--ROW_NUMBER는 동일 값이면 ROWID 순으로 순위부여(P405참고)

<div class = "code">
SELECT empno,ename,sal,ROWID
	,RANK() OVER (ORDER BY sal DESC)"RANK_OVER"
	,DENSE_RANK() OVER(ORDER BY sal DESC)"DENSE_RANK"
	,ROW_NUMBER() OVER(ORDER BY sal DESC)"ROW_NUMBER"
FROM emp;
--  EMPNO ENAME    SAL ROWID               RANK_OVER DENSE_RANK ROW_NUMBER
--------- ------ ----- ------------------ ---------- ---------- ----------
--   7839 KING    5000 AAAE6LAAEAAAAK+AAH          1          1          1
--   1000 Tiger   3600 AAAE6LAAEAAAAK9AAA          2          2          2
--   7902 FORD    3000 AAAE6LAAEAAAAK+AAK          3          3          3
--   2000 Cat     3000 AAAE6LAAEAAAAK9AAB          3          3          4
--   7566 JONES   2975 AAAE6LAAEAAAAK+AAD          5          4          5
--   7698 BLAKE   2850 AAAE6LAAEAAAAK+AAF          6          5          6
--   7782 CLARK   2450 AAAE6LAAEAAAAK+AAG          7          6          7
--   7499 ALLEN   1600 AAAE6LAAEAAAAK+AAB          8          7          8
--   7844 TURNER  1500 AAAE6LAAEAAAAK+AAI          9          8          9
--   7934 MILLER  1300 AAAE6LAAEAAAAK+AAL         10          9         10
--   7521 WARD    1250 AAAE6LAAEAAAAK+AAC         11         10         11
--   7654 MARTIN  1250 AAAE6LAAEAAAAK+AAE         11         10         12
--   7900 JAMES    950 AAAE6LAAEAAAAK+AAJ         13         11         13
--   7369 SMITH    800 AAAE6LAAEAAAAK+AAA         14         12         14
</div>
<a href="#그룹함수" name="SUM() OVER"><h4>SUM() OVER</h4></a><hr>
--SUM() OVER: 누계 구하기
--지점(P_STORE)별로 매출(P_STORE)누계를 구한다.
--SUM()_OVER 칼럼에서 매출이 누적되어 출력된다.

<div class = "code">
SELECT P_DATE, P_STORE, P_TOTAL
	,SUM(P_TOTAL) OVER(PARTITION BY P_STORE ORDER BY P_TOTAL)"SUM()_OVER"
FROM panmae;
--P_DATE           P_STORE       P_TOTAL SUM()_OVER
------------------ ---------- ---------- ----------
--20110103         1000             1600       1600
--20110102         1000             2000       3600
--20110101         1000             2400       6000
--20110102         1000             3000       9000
--20110103         1001             2400       2400
--20110104         1001             2700       5100
--20110104         1001             4000       9100
--20110101         1001             4500      13600
--20110104         1002             1600       1600
--20110104         1002             2000       3600
--20110102         1002             2400       6000
--20110104         1002             3600       9600
--20110102         1002             4500      14100
--20110104         1003             1800       1800
--20110101         1003             2000       3800
--20110104         1003             2700       6500
--20110104         1003             3200       9700
--20110103         1003             3600      13300
--20110104         1004             4000       4000
--20110101         1004             5400       9400
--20110103         1004             8000      17400
</div>
--SUM() OVER()에서 OVER에 PARTITION을 입력안하면 아래와 같이 총합/평균만 계속
--출력되도록 할 수 있다.

<div class = "code">
SELECT deptno, ename, sal
	,SUM(sal) OVER()"TOTAL"
	,ROUND(AVG(sal) OVER())"AVERAGE"
FROM emp;
-- DEPTNO ENAME                       SAL      TOTAL    AVERAGE
--------- -------------------- ---------- ---------- ----------
--     10 Tiger                      3600      31525       2252
--     10 Cat                        3000      31525       2252
--     20 SMITH                       800      31525       2252
--     30 ALLEN                      1600      31525       2252
--     30 WARD                       1250      31525       2252
--     20 JONES                      2975      31525       2252
--     30 MARTIN                     1250      31525       2252
--     30 BLAKE                      2850      31525       2252
--     10 CLARK                      2450      31525       2252
--     10 KING                       5000      31525       2252
--     30 TURNER                     1500      31525       2252
--     30 JAMES                       950      31525       2252
--     20 FORD                       3000      31525       2252
--     10 MILLER                     1300      31525       2252
</div>
<a href="#그룹함수" name="RATIO_TO_REPORT"><h4>RATIO_TO_REPORT</h4></a><hr>
--RATIO_TO_REPORT: 비율을 구하는 함수
--직원별 월급이 차지하는 비율 출력

<div class = "code">
SELECT deptno, ename, sal
	, ROUND(RATIO_TO_REPORT(sal) OVER()*100) "RATIO"
FROM emp
ORDER BY RATIO DESC;
--    DEPTNO ENAME                       SAL      RATIO
------------ -------------------- ---------- ----------
--        10 KING                       5000         16
--        10 Tiger                      3600         11
--        20 FORD                       3000         10
--        10 Cat                        3000         10
--        20 JONES                      2975          9
--        30 BLAKE                      2850          9
--        10 CLARK                      2450          8
--        30 ALLEN                      1600          5
--        30 TURNER                     1500          5
--        10 MILLER                     1300          4
--        30 WARD                       1250          4
--        30 MARTIN                     1250          4
--        20 SMITH                       800          3
--        30 JAMES                       950          3
</div>

--교수별 + 학과별로 교수의 임금이 차지하는 비율 출력
--RATIO_TO_REPORT의 OVER에 PARTITION BY 조건을 주고 값으로 학과(deptno)를 주면 학과별로
--각 교수의 임금이 차지하는 비율이 나온다.

<div class = "code">
SELECT deptno, name, pay
	,SUM(pay) OVER(PARTITION BY deptno)"TOTAL_DEPTNO"
	,ROUND(RATIO_TO_REPORT(pay) OVER(PARTITION BY deptno)*100,2)"RATIO %"
FROM professor;
--  DEPTNO NAME                     PAY TOTAL_DEPTNO    RATIO %
---------- -------------------- ------- ------------ ----------
--     101 Audie Murphy             550         1200      45.83
--     101 Angela Bassett           380         1200      31.67
--     101 Jessica Lange            270         1200       22.5
--     102 Winona Ryder             250         1090      22.94
--     102 Michelle Pfeiffer        350         1090      32.11
--     102 Whoopi Goldberg          490         1090      44.95
--     103 Emma Thompson            530         1150      46.09
--     103 Julia Roberts            330         1150       28.7
--     103 Sharon Stone             290         1150      25.22
--     201 Meryl Streep             570          900      63.33
--     201 Susan Sarandon           330          900      36.67
--     202 Nicole Kidman            310          570      54.39
--     202 Holly Hunter             260          570      45.61
--     203 Meg Ryan                 500          500        100
--     301 Andie Macdowell          220          510      43.14
--     301 Jodie Foster             290          510      56.86
</div>
<a href="#PIVOT" name="DECODE구현"><h4>DECODE구현</h4></a><hr>
--PIVOT: ROW단위를 COLUMN 단위로 변경
--컬럼 값을 기준으로 새로운 컬럼을 도출하여 다양한 집계함수를 적용가능

--유형1.달력만들기
--아래 테이블을 사용하여 달력을 출력한다.
--주차: WEEKNO VARCHAR2(1)
--요일: DAY VARCHAR2(5)
--날짜: DAYNO VARCHAR2(2)

<div class = "code">
  COL weekno FOR A6
  COL dayno FOR A5
  SELECT weekno, day, dayno
  FROM cal;
  --WEEKNO DAY        DAYNO
  -------- ---------- -----
  --1      SUN        1
  --1      MON        2
  --1      TUE        3
  --1      WED        4
  --1      THU        5
  --1      FRI        6
  --1      SAT        7
  --2      SUN        8
  --2      MON        9
  --2      TUE        10
  --2      WED        11
  --2      THU        12
  --2      FRI        13
  --2      SAT        14
  --3      SUN        15
  --3      MON        16
  --3      TUE        17
  --3      WED        18
  --3      THU        19
  --3      FRI        20
  --3      SAT        21
  --4      SUN        22
  --4      MON        23
  --4      TUE        24
  --4      WED        25
  --4      THU        26
  --4      FRI        27
  --4      SAT        28
  --5      SUN        29
  --5      MON        30
  --5      TUE        31
</div>
--유형1-1. DECODE함수로 달력 출력
--DECODE로 데이터의 요일(day)이 지정한 문자열과 같을 경우 해당날짜(dayno) 출력하도록 함

<div class = "code">
SELECT DECODE(day,'SUN',dayno,NULL)"SUN"
	  ,DECODE(day,'MON',dayno,NULL)"MON"
	  ,DECODE(day,'TUE',dayno,NULL)"TUE"
	  ,DECODE(day,'WED',dayno,NULL)"WED"
	  ,DECODE(day,'THU',dayno,NULL)"THU"
	  ,DECODE(day,'FRI',dayno,NULL)"FRI"
	  ,DECODE(day,'SAT',dayno,NULL)"SAT"
FROM cal;
--SUN  MON  TUE  WED  THU  FRI  SAT
------ ---- ---- ---- ---- ---- ----
--1
--     2
--          3
--               4
--                    5
--                         6
--                              7
--8
--     9
--          10
--               11
--                    12
--                         13
--                              14
--15
--     16
--          17
--               18
--                    19
--                         20
--                              21
--22
--     23
--          24
--               25
--                    26
--                         27
--                              28
--29
--     30
--          31
</div>

--빈칸을 제거하기 위해 MAX함수를 사용함
--데이터의 요일(day)이 지정한 문자열과 같아 해당날짜(dayno)이 출력된 곳 외에는 모두
--빈칸이기 때문에 MAX함수를 이용하면 해당 데이터만 출력되어 빈칸이 사라진다.

<div class = "code">
SELECT MAX(DECODE(day,'SUN',dayno,NULL))"SUN"
	  ,MAX(DECODE(day,'MON',dayno,NULL))"MON"
	  ,MAX(DECODE(day,'TUE',dayno,NULL))"TUE"
	  ,MAX(DECODE(day,'WED',dayno,NULL))"WED"
	  ,MAX(DECODE(day,'THU',dayno,NULL))"THU"
	  ,MAX(DECODE(day,'FRI',dayno,NULL))"FRI"
	  ,MAX(DECODE(day,'SAT',dayno,NULL))"SAT"
FROM cal
GROUP BY weekno
ORDER BY weekno;
--SUN  MON  TUE  WED  THU  FRI  SAT
------ ---- ---- ---- ---- ---- ----
--1    2    3    4    5    6    7
--8    9    10   11   12   13   14
--15   16   17   18   19   20   21
--22   23   24   25   26   27   28
--29   30   31
</div>
<a href="#PIVOT" name="달력구현"><h4>달력구현</h4></a><hr>
--SELECT문의 FROM에 SELECT문이 중첩된 것은 나중에 배우므로 일단 패스
--중첩된 SELECT문에 출력에 사용할 칼럼이 모두 입력이 되어있어야함
--PIVOT까지 하나의 쿼리이기 때문에 SELECT문에 세미콜론을 붙히지 않는다.
--MAX()함수의 파라미터에는 출력될 날짜(dayno)을 입력
--FOR에는 그룹핑할 컬럼인 요일(day)을 입력(요일별로 날짜를 출력할 것임)
--IN안에는 FOR에서 지정한 컬럼인 요일(day)의 값들을 넣는다.(반드시 FOR의 요소와 같아야함)
--AS로 컬럼명을 지정할 수 있다(변경가능)
--마지막에 주차(weekno)로 정렬해주면 완성

<div class = "code">
  SELECT * FROM(SELECT weekno"Wn",day,dayno FROM cal)
  PIVOT(
  	MAX(dayno) FOR day IN(
  		 'SUN' AS "토"
  		,'MON' AS "MON"
  		,'TUE' AS "TUE"
  		,'WED' AS "WED"
  		,'THU' AS "THU"
  		,'FRI' AS "FRI"
  		,'SAT' AS "일"
  	)
  )
  ORDER BY "Wn";
  --Wn 토   MON  TUE  WED  THU  FRI  일
  ---- ---- ---- ---- ---- ---- ---- ----
  --1  1    2    3    4    5    6    7
  --2  8    9    10   11   12   13   14
  --3  15   16   17   18   19   20   21
  --4  22   23   24   25   26   27   28
  --5  29   30   31
</div>
--만약 토요일과 일요일을 제외한 달력을 출력하고 싶다면
--'SUN' AS "SUN" 과 ,'SAT' AS "SAT"를 제거하면 된다.

<div class = "code">
  SELECT * FROM(SELECT weekno"Wn",day,dayno FROM cal)
  PIVOT(
  	MAX(dayno) FOR day IN(
  		 'MON' AS "MON"
  		,'TUE' AS "TUE"
  		,'WED' AS "WED"
  		,'THU' AS "THU"
  		,'FRI' AS "FRI"
  	)
  )
  ORDER BY "Wn";
  --Wn MON  TUE  WED  THU  FRI
  ---- ---- ---- ---- ---- ----
  --1  2    3    4    5    6
  --2  9    10   11   12   13
  --3  16   17   18   19   20
  --4  23   24   25   26   27
  --5  30   31
</div>
--그리고 토요일과 일요일 칸을 남겨둔채 날짜만 제외해서 출력하고 싶다면
--아래와 같이 IN함수에서 컬럼은 남겨둔채 파라미터만 NULL로 지정해 주면 된다.
--그러면 요일(day)값이 NULL인 데이터는 없으므로 칼럼명만 출력된채 데이터는 출력되지 않음

<div class = "code">
SELECT * FROM(SELECT weekno"Wn",day,dayno FROM cal)
PIVOT(
	MAX(dayno) FOR day IN(
		 NULL AS "SUN"
		,'MON' AS "MON"
		,'TUE' AS "TUE"
		,'WED' AS "WED"
		,'THU' AS "THU"
		,'FRI' AS "FRI"
		,NULL AS "SAT"
	)
)
ORDER BY "Wn";
--Wn SUN  MON  TUE  WED  THU  FRI  SAT
---- ---- ---- ---- ---- ---- ---- ----
--1       2    3    4    5    6
--2       9    10   11   12   13
--3       16   17   18   19   20
--4       23   24   25   26   27
--5       30   31
</div>
--유형2. PIVOT함수로 부서별로 직무별 인원을 출력
--SELECT문의 FROM에 SELECT문이 중첩된 것은 나중에 배우므로 일단 패스
--중첩된 SELECT문에 출력에 사용할 칼럼이 모두 입력이 되어있어야함
--PIVOT까지 하나의 쿼리이기 때문에 SELECT문에 세미콜론을 붙히지 않는다.
--사원번호(empno)를 기준으로 인원을 COUNT할 것이기때문에 empno를 COUNT의 파라미터로
--FOR에는 그룹핑할 컬럼인 job을 입력(직무별로 인원을 출력할 것임)
--IN안에는 FOR에서 지정한 컬럼인 직무(job)의 값들을 넣는다.(반드시 FOR의 요소와 같아야함)
--AS로 컬럼명을 지정할 수 있다(변경가능)
--마지막에 부서번호(deptno)로 정렬해주면 완성

<div class = "code">
SELECT * FROM(SELECT deptno,job,empno FROM emp)
PIVOT(
	COUNT(empno) FOR job IN(
		 'CLERK'     AS "CLERK"
		,'SALESMAN'  AS "SALESMAN"
		,'PRESIDENT' AS "PRESIDENT"
		,'MANAGER'   AS "MANAGER"
		,'ANALYST'   AS "ANALYST"
	)
)
ORDER BY deptno;
--    DEPTNO   CLERK SALESMAN PRESIDENT MANAGER ANALYST
------------ ------- -------- --------- ------- -------
--        10       1        0         1       1       0
--        20       1        0         0       1       1
--        30       1        4         0       1       0
</div>
<a href="#PIVOT" name="다중조건"><h4>다중조건</h4></a><hr>
--유형3. 부서별로 직무별 인원수와 월급의 총합을 출력
--PIVOT안에 두 개의 그룹함수를 사용함
--FOR와 IN에서 지정한 컬럼인 직무(job)을 기준으로 인원수(CNT)와 임금합계(SUM)가 계산됨

<div class = "code">
SELECT * FROM(SELECT deptno,job,empno,sal FROM emp)
PIVOT(
	COUNT(empno) AS CNT,
	SUM(sal) AS sum FOR job IN(
		 'CLERK'     AS "CLERK"
		,'SALESMAN'  AS "SALESMAN"
		,'PRESIDENT' AS "PRESIDENT"
		,'MANAGER'   AS "MANAGER"
		,'ANALYST'   AS "ANALYST"
	)
)
ORDER BY deptno;
--    DEPTNO  CLERK_CNT  CLERK_SUM SALESMAN_CNT SALESMAN_SUM PRESIDENT_CNT PRESIDENT_SUM MANAGER_CNT MANAGER_SUM ANALYST_CNT ANALYST_SUM
------------ ---------- ---------- ------------ ------------ ------------- ------------- ----------- ----------- ----------- -----------
--        10          1       1300            0                          1          5000           1        2450           0
--        20          1        800            0                          0                         1        2975           1        3000
--        30          1        950            4         5600             0                         1        2850           0
</div>
<a href="#PIVOT" name="가로세로컬럼"><h4>가로세로컬럼</h4></a><hr>

<div class = "code">
SELECT job
	,dept10
	,dept20
	,dept30
FROM(
	SELECT job
		,deptno
		,sal
	FROM emp
)
PIVOT(
	SUM(sal) FOR deptno IN (
		 '10' AS dept10
		,'20' AS dept20
		,'30' AS dept30
	)
);
--JOB                    DEPT10     DEPT20     DEPT30
-------------------- ---------- ---------- ----------
--CLERK                    1300        800        950
--SALESMAN                                       5600
--PRESIDENT                5000
--MANAGER                  2450       2975       2850
--ANALYST                             3000
</div>

<div class = "code">
COL jan FOR 999
COL feb FOR 999
COL mar FOR 999
COL apr FOR 999
COL may FOR 999
COL jun FOR 999
COL jul FOR 999
COL aug FOR 999
COL sep FOR 999
COL oct FOR 999
COL nov FOR 999
COL dec FOR 999
SELECT job
	,jan
	,feb
	,mar
	,apr
	,may
	,jun
	,jul
	,aug
	,sep
	,oct
	,nov
	,dec
FROM (
	SELECT job
		,empno
		,SUBSTR(hiredate,4,2)"month"
	FROM emp
)
PIVOT(
	COUNT(empno) FOR "month" IN(
		 '01' AS jan
		,'02' AS feb
		,'03' AS mar
		,'04' AS apr
		,'05' AS may
		,'06' AS jun
		,'07' AS jul
		,'08' AS aug
		,'09' AS sep
		,'10' AS oct
		,'11' AS nov
		,'12' AS dec
	)
)ORDER BY job;
--JOB                 JAN  FEB  MAR  APR  MAY  JUN  JUL  AUG  SEP  OCT  NOV  DEC
-------------------- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
--ANALYST               0    0    0    0    0    0    0    0    0    0    0    1
--CLERK                 1    0    0    0    0    0    0    0    0    0    0    2
--MANAGER               0    0    0    1    1    1    0    0    0    0    0    0
--PRESIDENT             0    0    0    0    0    0    0    0    0    0    1    0
--SALESMAN              0    2    0    0    0    0    0    0    2    0    0    0
</div>
<a href="#JOIN" name="PIVOT_CUBE"><h4>PIVOT_CUBE</h4></a><hr>

<div class = "code">
SELECT * FROM(
--'TOTAL'을 변경하기 위해서는 PIVOT문의 IN절 안의 'TOTAL'도 동일하게 변경해야함
	SELECT NVL(TO_CHAR(deptno),'TOTAL') deptno,
	--NVL안의 'TOTAL'은 자유롭게 변경가능
		NVL(job,'TOTAL')JOB,
		SUM(sal) SAL
	FROM emp
	GROUP BY CUBE(deptno,job)
	ORDER BY deptno,job
)
PIVOT(
	SUM(sal) FOR deptno IN(
		10,
		20,
		30,
		'TOTAL'
	)
)ORDER BY 1
;
--JOB                        10         20         30    'TOTAL'
-------------------- ---------- ---------- ---------- ----------
--ANALYST                             3000                  3000
--CLERK                    1300        800        950       3050
--MANAGER                  2450       2975       2850       8275
--PRESIDENT                5000                             5000
--SALESMAN                                       5600       5600
--TOTAL                    8750       6775       9400      24925
</div>

<div class = "code">
COL deptno FOR A7
SELECT * FROM(
--NVL안의 'TOTAL'은 자유롭게 변경가능
	SELECT NVL(TO_CHAR(deptno),'TOTAL') deptno,
	--'TOTAL'을 변경하기 위해서는 PIVOT문의 IN절 안의 'TOTAL'도 동일하게 변경해야함
		NVL(job,'TOTAL') job,
		SUM(sal) SAL
	FROM emp
	GROUP BY CUBE(deptno,job)
	ORDER BY deptno,job
)
PIVOT(
	SUM(sal) FOR job IN(
		 'CLERK'     AS "CLERK",
		 'SALESMAN'  AS "SALESMAN",
		 'PRESIDENT' AS "PRESIDENT",
		 'MANAGER'   AS "MANAGER",
		 'ANALYST'   AS "ANALYST",
		 'TOTAL'
	)
)ORDER BY deptno
;
--DEPTNO       CLERK   SALESMAN  PRESIDENT    MANAGER    ANALYST    'TOTAL'
--------- ---------- ---------- ---------- ---------- ---------- ----------
--10            1300                  5000       2450                  8750
--20             800                             2975       3000       6775
--30             950       5600                  2850                  9400
--TOTAL         3050       5600       5000       8275       3000      24925
</div>
<a href="#JOIN" name="JOIN_기본설명"><h4>JOIN_기본설명</h4></a><hr>
--JOIN
--여러 테이블에 흩어져 있는 데이터들을 조합해서 가져오는 기술
--ORACLE과 ANSI join 문법이 다름

--ORACLE JOIN
--SELECT t1.col1, t2.col1
--FROM table t1, table t2 //보통 alias를 지정
--WHERE t1.col1 = t2.col1
--join조건이 where에 붙음

--ANSI JOIN
--SELECT t1.col1, t2.col1
--FROM table t1 [INNER] JOIN table t2
--ON t1.col1 = t2.col1
--join 조건이 ON에 붙음

--JOIN에 사용되는 용어
--선행테이블(driving table, inner table)과 후행테이블(driven table, outer table)
--조인이 사용될 때 두 개 이상의 테이블이 사용되는데 이때 둘 중 하나의 테이블을 먼저 읽고(선행테이블)
--JOIN조건절을 이용해 나머지 테이블(후행테이블)에 가서 데이터를 가져옴
--선행테이블은 조회할 데이터가 적은 테이블로 선택해야 속도면에서 유리함

<a href="#JOIN" name="CARTESIAN_PRODUCT"><h4>CARTESIAN_PRODUCT</h4></a><hr>
--CARTESIAN_PRODUCT
--JOIN 조건을 잘못 주거나 주지않았을 때 해당 테이블에 대한 모든 데이터를 가져오는 현상
--일부러 쓰기도 함
--데이터를 복제해서 원본 테이블을 반복해서 읽는 것을 피하기 위해

--JOIN 2개 테이블

<div class = "code">
SELECT t1.no, t1.name, t2.name
FROM cat_a t1, cat_b t2
WHERE t1.no = t2.no;
-- NO NAME NAME
----- ---- ----
--  1 A    C
--  2 B    D
</div>
--CARTESIAN PRODUCT
--WHERE로 JOIN 조건을 지정해 주지 않았기에 발생

<div class = "code">
SELECT t1.no, t1.name, t2.name
FROM cat_a t1, cat_b t2;
--WHERE t1.no = t2.no;
-- NO NAME NAME
----- ---- ----
--  1 A    C
--  1 A    D
--  2 B    C
--  2 B    D
</div>
--JOIN 3개 테이블

<div class = "code">
SELECT t1.no, t1.name, t2.name, t3.name
FROM cat_a t1, cat_b t2, cat_c t3
WHERE t1.no = t2.no AND t2.no = t3.no;
-- NO NAME NAME NAME
----- ---- ---- ----
--  1 A    C    E
--  2 B    D    F
</div>
--CARTESIAN PRODUCT
--WHERE로 JOIN 조건을 지정해 주지 않았기에 발생

<div class = "code">
SELECT t1.no, t1.name, t2.name, t3.name
FROM cat_a t1, cat_b t2, cat_c t3;
--WHERE t1.no = t2.no AND t2.no = t3.no;
-- NO NAME NAME NAME
----- ---- ---- ----
--  1 A    C    E
--  1 A    C    F
--  1 A    D    E
--  1 A    D    F
--  2 B    C    E
--  2 B    C    F
--  2 B    D    E
--  2 B    D    F
</div>
--CARTESIAN PRODUCT
--쿼리가 잘 작동하는지(속도가 빠른지) 테스트하기 위해서 대량의 데이터를 만드는 방법
--기존건수 X level 만큼 데이터가 나옴

<div class = "code">
SELECT *
FROM(
	SELECT empno, ename, job, sal
	FROM emp
	WHERE deptno = 10
)
,(
	SELECT LEVEL
	FROM dual
	CONNECT BY level <= 3
);
--  EMPNO ENAME       JOB             SAL  LEVEL
--------- ----------- ------------ ------ ------
--   7782 CLARK       MANAGER        2450      1
--   7839 KING        PRESIDENT      5000      1
--   7934 MILLER      CLERK          1300      1
--   7782 CLARK       MANAGER        2450      2
--   7839 KING        PRESIDENT      5000      2
--   7934 MILLER      CLERK          1300      2
--   7782 CLARK       MANAGER        2450      3
--   7839 KING        PRESIDENT      5000      3
--   7934 MILLER      CLERK          1300      3
</div>
<a href="#JOIN" name="EQUI_JOIN"><h4>EQUI_JOIN</h4></a><hr>
--유형1. emp테이블과 dept테이블을 조회하여 직원번호, 직원이름, 부서번호, 부서이름을 출력하시오.

<div class = "code">
--  EMPNO ENAME          DEPTNO DNAME
--------- ---------- ---------- -------------
--   7839 KING               10 ACCOUNTING
--   7782 CLARK              10 ACCOUNTING
--   7934 MILLER             10 ACCOUNTING
--   7902 FORD               20 RESEARCH
--   7369 SMITH              20 RESEARCH
--   7566 JONES              20 RESEARCH
--   7900 JAMES              30 SALES
--   7844 TURNER             30 SALES
--   7654 MARTIN             30 SALES
--   7521 WARD               30 SALES
--   7499 ALLEN              30 SALES
--   7698 BLAKE              30 SALES
</div>
--ORACLE

<div class = "code">
SELECT empno, ename, t1.deptno, t2.dname
FROM emp t1, dept t2
WHERE t1.deptno = t2.deptno;
</div>
--ANSI

<div class = "code">
SELECT empno, ename, t1.deptno, t2.dname
FROM emp t1 JOIN dept t2
ON t1.deptno = t2.deptno;
</div>
--유형2. 학생테이블과 교수테이블을 조인, 학생이름과 교수이름을 조인

<div class = "code">
--student             professor
--------------------  -------------------
--James Seo           Audie Murphy
--Billy Crystal       Angela Bassett
--Richard Dreyfus     Angela Bassett
--Tim Robbins         Winona Ryder
--Rene Russo          Winona Ryder
--Nicholas Cage       Michelle Pfeiffer
--Sandra Bullock      Julia Roberts
--Demi Moore          Meryl Streep
--Macaulay Culkin     Meryl Streep
--Wesley Snipes       Susan Sarandon
--Danny Glover        Nicole Kidman
--Micheal Keaton      Nicole Kidman
--Steve Martin        Nicole Kidman
--Daniel Day-Lewis    Jodie Foster
--Bill Murray         Jodie Foster
</div>
--ORACLE

<div class = "code">
SELECT t1.name"student", t2.name"professor"
FROM student t1, professor t2
WHERE t1.profno = t2.profno;
</div>
--ANSI

<div class = "code">
SELECT t1.name"student", t2.name"professor"
FROM student t1 JOIN professor t2
ON t1.profno = t2.profno;
</div>
--유형3. 학생이름, 학과이름, 학생의 지도교수 이름

<div class = "code">
--student_name         professor_name       dept_name
---------------------- -------------------- -----------------------------------
--James Seo            Audie Murphy         Computer Engineering
--Billy Crystal        Angela Bassett       Computer Engineering
--Richard Dreyfus      Angela Bassett       Computer Engineering
--Tim Robbins          Winona Ryder         Multimedia Engineering
--Rene Russo           Winona Ryder         Multimedia Engineering
--Nicholas Cage        Michelle Pfeiffer    Multimedia Engineering
--Sandra Bullock       Julia Roberts        Software Engineering
--Macaulay Culkin      Meryl Streep         Electronic Engineering
--Demi Moore           Meryl Streep         Electronic Engineering
--Wesley Snipes        Susan Sarandon       Electronic Engineering
--Micheal Keaton       Nicole Kidman        Mechanical Engineering
--Danny Glover         Nicole Kidman        Mechanical Engineering
--Steve Martin         Nicole Kidman        Electronic Engineering
--Bill Murray          Jodie Foster         Library and Information science
--Daniel Day-Lewis     Jodie Foster         Library and Information science
</div>
--ORACLE

<div class = "code">
COL "student_name" FOR A20
COL "professor_name" FOR A20
COL "dept_name"  FOR A35
SELECT t1.name"student_name"
	,t2.name"professor_name"
	,t3.dname"dept_name"
FROM student t1, professor t2, department t3
WHERE t1.profno = t2.profno
AND t1.deptno1 = t3.deptno
;
</div>
--ANSI

<div class = "code">
COL "student_name" FOR A20
COL "professor_name" FOR A20
COL "dept_name"  FOR A35
SELECT t1.name"student_name"
	,t2.name"professor_name"
	,t3.dname"dept_name"
FROM student t1 JOIN professor t2
ON t1.profno = t2.profno
JOIN department t3
ON t1.deptno1 = t3.deptno
;
</div>
--유형4. student테이블과 professor테이블을 조회하여 학생의 제1전공이 101번인 학생들의
--이름, 지도교수를 출력하세요.

<div class = "code">
--student_name         professor_name          DEPTNO1
---------------------- -------------------- ----------
--James Seo            Audie Murphy                101
--Richard Dreyfus      Angela Bassett              101
--Billy Crystal        Angela Bassett              101
</div>
--ORACLE

<div class = "code">
SELECT t1.name"student_name"
	,t2.name"professor_name"
	,t1.deptno1
FROM student t1, professor t2
WHERE t1.profno = t2.profno
AND t1.deptno1 = 101
;
</div>
--ANSI

<div class = "code">
SELECT t1.name"student_name"
	,t2.name"professor_name"
	,t1.deptno1
FROM student t1 JOIN professor t2
ON t1.profno = t2.profno
WHERE t1.deptno1 = 101
;
</div>
<a href="#JOIN" name="NON_EQUI_JOIN"><h4>NON_EQUI_JOIN</h4></a><hr>
--NON_EQUI_JOIN: 비등가 조인

--유형1. CUSTOMER 테이블과, GIFT테이블을 조회하여 고객별로 마일리지 포인트를 조회하여,
--마일리지별 받을 수 있는 상품을 조회하여라.

<div class = "code">
CUSTOMER_NAME             POINT GIFT_NAME
-------------------- ---------- --------------------
Bill Pullman              65000 Tuna Set
Mel Gibson                73000 Tuna Set
Michael Douglas           99000 Tuna Set
Brad Pitt                110000 Shampoo Set
Samuel Jackson           153000 Shampoo Set
Liam Neeson              180000 Shampoo Set
Arnold Scharz            265000 Car wash Set
Ahnjihye                 273000 Car wash Set
Tom Hanks                298000 Car wash Set
Jim Carrey               315000 Kitchen Supplies Set
Bruce Willis             320000 Kitchen Supplies Set
Angela Bassett           420000 Mountain bike
Robin Williams           470000 Mountain bike
Morgan Freeman           542000 LCD Monitor
Jessica Lange            598000 LCD Monitor
Winona Ryder             625000 Notebook
Michelle Pfeiffer        670000 Notebook
James Seo                980000 Refrigerator
</div>
--ORACLE

<div class = "code">
COL "CUSTOMER_NAME" FOR A20
COL "GIFT_NAME" FOR A20
SELECT t1.gname"CUSTOMER_NAME", t1.point"POINT", t2.gname"GIFT_NAME"
FROM customer t1, gift t2
WHERE t1.point BETWEEN t2.g_start AND t2.g_end
;
</div>
--ANSI

<div class = "code">
COL "CUSTOMER_NAME" FOR A20
COL "GIFT_NAME" FOR A20
SELECT t1.gname"CUSTOMER_NAME", t1.point"POINT", t2.gname"GIFT_NAME"
FROM customer t1 JOIN gift t2
ON t1.point BETWEEN t2.g_start AND t2.g_end
--ON t1.point >= t2.g_start
--AND t1.point <= t2.g_end
;
</div>

--유형2. 학생테이블과 SCORE테이블, HAKJUM테이블을 조회하여 학생이름, 점수, 학점을 출력하세요

<div class = "code">
--SCORE     TYPE    NULL     --HAKJUM    TYPE    NULL
--STUDNO    NUMBER  YES      --GRADE     CHAR(3) YES
--TOTAL     NUMBER  YES      --MIN_POINT NUMBER  YES
                             --MAX_POINT NUMBER  YES

--STUDENT_NAEM              SCORE GRADE
---------------------- ---------- ------
--James Seo                    97 A+
--Macaulay Culkin              95 A0
--Billy Crystal                92 A0
--Danny Devito                 91 A0
--Richard Dreyfus              89 B+
--Sean Connery                 88 B+
--Danny Glover                 88 B+
--Nicholas Cage                87 B+
--Daniel Day-Lewis             87 B+
--Wesley Snipes                86 B+
--Anthony Hopkins              84 B0
--Sandra Bullock               83 B0
--Charlie Sheen                83 B0
--Steve Martin                 82 B0
--Christian Slater             82 B0
--Micheal Keaton               81 B0
--Bill Murray                  79 C+
--Rene Russo                   78 C+
--Tim Robbins                  77 C+
--Demi Moore                   62 D
</div>
--ORACLE

<div class = "code">
COL "STUDENT_NAEM" FOR A20
SELECT t3.name"STUDENT_NAEM", t1.total"SCORE", t2.grade"GRADE"
FROM score t1, hakjum t2, student t3
WHERE t1.total BETWEEN t2.min_point AND t2.max_point
AND t1.studno = t3.studno
;
</div>
--ANSI

<div class = "code">
COL "STUDENT_NAEM" FOR A20
SELECT t3.name"STUDENT_NAEM", t1.total"SCORE", t2.grade"GRADE"
FROM score t1 JOIN hakjum t2
ON t1.total BETWEEN t2.min_point AND t2.max_point
JOIN student t3
ON t1.studno = t3.studno
;
</div>
<a href="#JOIN" name="OUTER_JOIN"><h4>OUTER_JOIN</h4></a><hr>
--OUTER_JOIN
--한쪽 테이블에는 데이터가 있고 다른쪽에는 데이터가 없는 경우
--데이터가 있는 쪽에 테이블의 내용을 모두 출력

--유형1. 지도교수가 결정되지 않은 학생의 명단도 출력

<div class = "code">
--STU_NAME                   PROF_NAME
---------------------------- ---------------------
--James Seo                  Audie Murphy
--Richard Dreyfus            Angela Bassett
--Billy Crystal              Angela Bassett
--Tim Robbins                Winona Ryder
--Rene Russo                 Winona Ryder
--Nicholas Cage              Michelle Pfeiffer
--Sandra Bullock             Julia Roberts
--Macaulay Culkin            Meryl Streep
--Demi Moore                 Meryl Streep
--Wesley Snipes              Susan Sarandon
--Steve Martin               Nicole Kidman
--Micheal Keaton             Nicole Kidman
--Danny Glover               Nicole Kidman
--Daniel Day-Lewis           Jodie Foster
--Bill Murray                Jodie Foster
--Anthony Hopkins
--Charlie Sheen
--Christian Slater
--Sean Connery
--Danny Devito
</div>
--ORACLE
--데이터가 없는 쪽 조인조건에 (+)

<div class = "code">
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
FROM student t1, professor t2
WHERE t1.profno = t2.profno(+);
</div>
--ANSI
--LEFT OUTER JOIN: 데이터가 있는 쪽이 왼쪽
--RIGHT OUTER JOIN: 데이터가 있는 쪽이 오른쪽

<div class = "code">
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
--FROM student t1 LEFT OUTER JOIN professor t2
FROM professor t2 RIGHT OUTER JOIN student t1
ON t1.profno = t2.profno;
</div>
--유형2. 지도학생이 결정되지 않은 교수의 명단도 출력

<div class = "code">
--STU_NAME                                                     PROF_NAME
-------------------------------------------------------------- -------------------
--James Seo                                                    Audie Murphy
--Billy Crystal                                                Angela Bassett
--Richard Dreyfus                                              Angela Bassett
--                                                             Jessica Lange
--Tim Robbins                                                  Winona Ryder
--Rene Russo                                                   Winona Ryder
--Nicholas Cage                                                Michelle Pfeiffer
--                                                             Whoopi Goldberg
--                                                             Emma Thompson
--Sandra Bullock                                               Julia Roberts
--                                                             Sharon Stone
--Demi Moore                                                   Meryl Streep
--Macaulay Culkin                                              Meryl Streep
--Wesley Snipes                                                Susan Sarandon
--Danny Glover                                                 Nicole Kidman
--Micheal Keaton                                               Nicole Kidman
--Steve Martin                                                 Nicole Kidman
--                                                             Holly Hunter
--                                                             Meg Ryan
--                                                             Andie Macdowell
--Daniel Day-Lewis                                             Jodie Foster
--Bill Murray                                                  Jodie Foster
</div>
--ORACLE

<div class = "code">
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
FROM student t1, professor t2
WHERE t1.profno(+) = t2.profno;
</div>
--ANSI

<div class = "code">
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
--FROM student t1 LEFT OUTER JOIN professor t2
FROM student t1 RIGHT OUTER JOIN professor t2
ON t1.profno = t2.profno;
</div>
--유형3. 지도학생이 결정되지 않은 교수들, 지도교수가 결정되지 않은 학생들의 이름 전부 출력

<div class = "code">
--STU_NAME                 PROF_NAME
-------------------------- -------------------------
--Anthony Hopkins
--Bill Murray              Jodie Foster
--Billy Crystal            Angela Bassett
--Charlie Sheen
--Christian Slater
--Daniel Day-Lewis         Jodie Foster
--Danny Devito
--Danny Glover             Nicole Kidman
--Demi Moore               Meryl Streep
--James Seo                Audie Murphy
--Macaulay Culkin          Meryl Streep
--Micheal Keaton           Nicole Kidman
--Nicholas Cage            Michelle Pfeiffer
--Rene Russo               Winona Ryder
--Richard Dreyfus          Angela Bassett
--Sandra Bullock           Julia Roberts
--Sean Connery
--Steve Martin             Nicole Kidman
--Tim Robbins              Winona Ryder
--Wesley Snipes            Susan Sarandon
--                         Andie Macdowell
--                         Emma Thompson
--                         Holly Hunter
--                         Jessica Lange
--                         Meg Ryan
--                         Sharon Stone
--                         Whoopi Goldberg
</div>
--ORACLE

<div class = "code">
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
FROM student t1, professor t2
WHERE t1.profno = t2.profno(+)
UNION
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
FROM student t1, professor t2
WHERE t1.profno(+) = t2.profno;
</div>
--ANSI

<div class = "code">
SELECT t1.name"STU_NAME"
	,t2.name"PROF_NAME"
--FROM student t1 LEFT OUTER JOIN professor t2
FROM student t1 FULL OUTER JOIN professor t2
ON t1.profno = t2.profno;
</div>
--ORACLE OUTER JOIN 주의사항
--1.OUTER JOIN이 되는 컬럼들에 대해서는 전부 아우터 조인 연산자(+)를 붙여햐 한다.
--하나라도 누락이 되면 일반 조인과 동일한 결과를 출력하게 된다.

--ORACLE

<div class = "code">
SELECT t1.deptno
	,t2.dname
	,t1.empno
	,t1.ename
	,t1.sal
FROM emp t1, dept t2
WHERE t1.deptno(+) = t2.deptno
AND t1.deptno(+) = 20;
--    DEPTNO DNAME                             EMPNO        SAL
------------ ---------------------------- ---------- ----------
--           ACCOUNTING
--        20 RESEARCH                           7369        800
--        20 RESEARCH                           7902       3000
--        20 RESEARCH                           7566       2975
--           SALES
--           OPERATIONS
</div>
--ANSI
--직업이 CLERK인 사원정보(사원번호, 이름ㅁ, 직업)을 출력하고 그 중에 'CHICAGO'에 위치한 부서에
--소속된 사원의 부서정보를 출력하세요
--emp, dept
--ANSI OUTER JOIN에서 WHERE절에 기술한 조건은 기준 테이블의
--집합수를 결정하고 ON절에 기술한 조건은 기준 집합 중에 아우터 조인 대상이 되는
--집합을 말하는 것으로 전체 집합에는 아무러 영향을 주지 않는다.

<div class = "code">
SELECT t1.empno, t1.ename, t1.job, t2.deptno, t2.dname, t2.loc
FROM emp t1 LEFT OUTER JOIN dept t2
ON(
	t1.deptno = t2.deptno
	AND t2.loc = 'CHICAGO'
	AND t1.job = 'CLERK'
)
--WHERE t1.job = 'CLERK'
;
--     EMPNO ENAME       JOB             DEPTNO DNAME   LOC
------------ ----------- ----------- ---------- ------- ---------
--      7900 JAMES       CLERK               30 SALES   CHICAGO
--      2000 Cat
--      1000 Tiger
--      7369 SMITH       CLERK
--      7782 CLARK       MANAGER
--      7844 TURNER      SALESMAN
--      7654 MARTIN      SALESMAN
--      7521 WARD        SALESMAN
--      7499 ALLEN       SALESMAN
--      7566 JONES       MANAGER
--      7934 MILLER      CLERK
--      7902 FORD        ANALYST
--      7839 KING        PRESIDENT
--      7698 BLAKE       MANAGER
</div>
<a href="#JOIN" name="SELF_JOIN"><h4>SELF_JOIN</h4></a><hr>
--SELF_JOIN: 한 개의 테이블을 가지고 JOIN
--사원과 해당 사원의 매니저의 이름을 출력

<div class = "code">
--ENAME                ENAME
---------------------- ------------
--FORD                 JONES
--JAMES                BLAKE
--TURNER               BLAKE
--WARD                 BLAKE
--MARTIN               BLAKE
--ALLEN                BLAKE
--MILLER               CLARK
--CLARK                KING
--JONES                KING
--BLAKE                KING
--SMITH                FORD
</div>
--ORACLE

<div class = "code">
SELECT t1.ename
	,t2.ename
FROM emp t1, emp t2
WHERE t1.mgr = t2.empno
;
</div>
--ANSI

<div class = "code">
SELECT t1.ename
	,t2.ename
FROM emp t1 INNER JOIN emp t2
ON t1.mgr = t2.empno
;
</div>
<a href="#DDL" name="명령어_구분"><h4>명령어_구분</h4></a><hr>
--DDL(Data Discription Language)
--CREATE, ALTER, TRUNCATE, DROP

--DML(Data Manipulation Language)
--INSERT, UPDATE, DELETE, MERGE

--DCL(Data Control Language)
--GRANT, REVOKE

--TCL(transaction Control Language)
--COMMIT, ROLLBACK

--DQL(Data Query Language)
--SELECT
<a href="#DDL" name="CREATE"><h4>CREATE</h4></a><hr>
--테이블생성 제약사항
--테이블이름은 반드시 문자로 시작해야 함(숫자로 시작할 수 없음)
--테이블 컬럼의 이름은 30BYTE까지 가능
--테이블 이름은 한 명의 사용자가 다른 오브젝트의 이름과 중복으로 사용할 수 없다.
--테이블 이름이나 컬럼이름을 오라클 키워드로 지정해서는 안됨

--DEFAULT 설정하기

<div class = "code">
CREATE TABLE tt02(
	no NUMBER(3,1) DEFAULT 0,
	name VARCHAR2(10 BYTE) DEFAULT 'No NAME',
	hiredate DATE DEFAULT SYSDATE
);
</div>
--한글테이블 생성
--생성은 가능하나 쓰는 경우는 없다.

<div class = "code">
CREATE TABLE 한글테이블(
	컬럼1 NUMBER,
	컬럼2 VARCHAR2,
	컬럼3 DATE
);
</div>
<a href="#DDL" name="CTAS"><h4>CTAS</h4></a>
--테이블 복사하기(CTAS)
--유형1. 모든컬럼 복사,데이터 복사

<div class = "code">
CREATE
TABLE dept3
AS
SELECT * FROM dept;
</div>
--테이블 존재여부 확인

<div class = "code">
SELECT *
FROM tab
WHERE tname LIKE 'DEPT3%';
</div>
--유형2. 테이블 구조만 가져오기(CATA)

<div class = "code">
CREATE TABLE dept4
AS
SELECT * FROM dept
WHERE 1=2;
</div>
--유형3. 특정 컬럼만 가져오기

<div class = "code">
CREATE TABLE dept5
AS
SELECT deptno, dname
FROM dept;
</div>
<a href="#DDL" name="ALTER"><h4>ALTER</h4></a>
--ALTER
--OBJECT를 변경하는 명령어
--컬럼 추가, 삭제, 데이터 타입수정
--부하가 많이 걸리는 명령어로 사용량이 많은 시간에 수행하면 안됨

--컬럼추가

<div class = "code">
ALTER TABLE dept6
ADD (LOCATION VARCHAR2(10 BYTE));
</div>
--컬럼추가&디폴트값

<div class = "code">
ALTER TABLE dept6
ADD (LOCATION2 VARCHAR2(10 BYTE) DEFAULT 'SEOUL')
;
</div>
--테이블 컬럼이름 변경

<div class = "code">
ALTER TABLE dept6
RENAME COLUMN LOCATION2 TO LOC02
;
</div>
--테이블이름 변경

<div class = "code">
RENAME TABLE dept6 TO dept7
;
</div>
--컬럼의 데이터크기 변경

<div class = "code">
ALTER TABLE dept6
MODIFY (LOC VARCHAR2(20 BYTE))
;
</div>
--컬럼 삭제

<div class = "code">
ALTER TABLE dept6
DROP COLUMN LOC
;
</div>
--참조키가 있는 컬럼삭제

<div class = "code">
ALTER TABLE dept6
DROP COLUMN LOC CASCADE CONSTRAINTS
;
</div>





</pre>
</body>

</html>
